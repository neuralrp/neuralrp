<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuralRP</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%231e293b'/><text x='50' y='65' font-size='40' text-anchor='middle' fill='%2394a3b8'>*-*</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        [x-cloak] { display: none !important; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        .no-scrollbar::-webkit-scrollbar { display: none; }

        /* Mobile/ToucH Optimizations */
        @media (max-width: 768px) {
            /* Increase touch target sizes */
            .group-hover\\:flex {
                display: none;
            }
            
            /* Make buttons more touch-friendly */
            button {
                min-height: 44px; /* Apple's recommended minimum touch target */
                min-width: 44px;
                padding: 12px 16px;
            }
            
            /* Sidebar adjustments for mobile */
            .w-80 {
                width: 100%;
                max-width: 320px;
            }
            
            /* Input area adjustments */
            .rounded-\[24px\] {
                border-radius: 16px;
            }
            
            /* Character edit interface adjustments */
            .sticky\.bottom-0 {
                position: relative;
                bottom: auto;
            }
            
            /* World info entry buttons */
            .flex\.gap-1\.mt-2 {
                margin-top: 8px;
                gap: 8px;
            }
            
            /* Chat message spacing */
            .space-y-8 > * {
                margin-bottom: 16px;
            }
            
            /* Header adjustments */
            .h-14 {
                height: 56px;
            }
            
            /* Sidebar header */
            .p-4 {
                padding: 16px;
            }
        }
        
        /* Tablet optimizations */
        @media (min-width: 769px) and (max-width: 1024px) {
            .grid-cols-1\.md\:grid-cols-2 {
                grid-template-columns: 1fr;
            }
            
            .grid-cols-1\.md\:grid-cols-2\.lg\:grid-cols-3 {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 h-screen overflow-hidden font-sans" x-data="chatUI()">
    <div class="flex h-full">
        <!-- Sidebar -->
        <div class="w-80 bg-slate-800 border-r border-slate-700 flex flex-col transition-all duration-300" :class="showSidebar === 'none' ? '-ml-80' : ''">
            <div class="p-4 border-b border-slate-700 font-bold flex justify-between items-center bg-slate-900/50">
                <span class="text-xs tracking-widest text-slate-400" x-text="showSidebar.toUpperCase()"></span>
                <button @click="showSidebar = 'none'" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="flex-1 overflow-y-auto p-4 space-y-4">
                
                <!-- Chats Sidebar -->
                <template x-if="showSidebar === 'chats'">
                    <div class="space-y-4">
                        <div class="flex gap-2">
                            <button @click="saveNewChat()" class="flex-1 bg-green-600 hover:bg-green-500 py-2 rounded-lg text-xs font-bold shadow-lg shadow-green-900/20 transition-all uppercase tracking-widest">Save Session</button>
                            <button @click="fetchChats()" class="bg-slate-700 hover:bg-slate-600 px-3 rounded-lg text-slate-300" title="Refresh List"><i class="fa-solid fa-rotate"></i></button>
                        </div>
                        
                        <!-- Main Chats -->
                        <div class="space-y-2">
                            <div class="text-[9px] font-black uppercase tracking-widest text-slate-500 border-b border-slate-700 pb-1">Main Timelines</div>
                            <template x-for="chat in savedChats" :key="chat.id">
                                <div class="group flex items-center gap-2 p-3 bg-slate-700/30 hover:bg-slate-700/60 rounded-xl cursor-pointer border border-transparent transition-all" :class="isBranch(chat.id) ? 'opacity-75' : ''">
                                    <div @click="loadChat(chat.id)" class="flex-1 min-w-0">
                                        <div class="font-bold text-sm truncate" x-text="chat.branch_name || getDisplayName(chat.id)"></div>
                                        <template x-if="isBranch(chat.id)">
                                            <div class="text-[9px] text-slate-500 truncate" x-text="'Branch of ' + getBranchOrigin(chat.id)"></div>
                                        </template>
                                    </div>
                                    <div class="flex gap-1">
                                        <button @click="deleteChat(chat.id)" class="hidden group-hover:flex w-6 h-6 rounded-lg bg-slate-800 hover:bg-red-600 text-white items-center justify-center transition-all"><i class="fa-solid fa-trash text-[10px]"></i></button>
                                    </div>
                                </div>
                            </template>
                        </div>
                        
                        <!-- Branches Section -->
                        <template x-if="currentChatBranches.length > 0">
                            <div class="space-y-2">
                                <div class="text-[9px] font-black uppercase tracking-widest text-slate-500 border-b border-slate-700 pb-1">Active Branches</div>
                                <template x-for="branch in currentChatBranches" :key="branch.name">
                                    <div class="group flex items-center gap-2 p-3 bg-slate-700/30 hover:bg-slate-700/60 rounded-xl cursor-pointer border border-transparent transition-all">
                                        <div @click="loadChat(branch.name)" class="flex-1 min-w-0">
                                            <div class="font-bold text-sm truncate" x-text="branch.branch_name || branch.name"></div>
                                            <div class="text-[9px] text-slate-500 truncate" x-text="'Created ' + formatTime(branch.created_at)"></div>
                                        </div>
                                        <div class="flex gap-1">
                                            <button @click="renameBranchDialog(branch)" class="hidden group-hover:flex w-6 h-6 rounded-lg bg-slate-800 hover:bg-yellow-600 text-white items-center justify-center transition-all" title="Rename Branch"><i class="fa-solid fa-pen text-[10px]"></i></button>
                                            <button @click="deleteChat(branch.name)" class="hidden group-hover:flex w-6 h-6 rounded-lg bg-slate-800 hover:bg-red-600 text-white items-center justify-center transition-all"><i class="fa-solid fa-trash text-[10px]"></i></button>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </template>
                    </div>
                </template>

                <!-- Character Sidebar -->
                <template x-if="showSidebar === 'characters'">
                    <div class="space-y-4">
                        <div class="flex gap-2">
                            <button @click="startNewCharacter()" class="flex-1 bg-blue-600 hover:bg-blue-500 py-2 rounded-lg text-xs font-black uppercase tracking-widest transition-all">New Character</button>
                            <button @click="fetchCharacters()" class="bg-slate-700 hover:bg-slate-600 px-3 rounded-lg text-slate-300" title="Refresh List"><i class="fa-solid fa-rotate"></i></button>
                        </div>
                        
                        <!-- Character Editing Interface -->
                        <template x-if="editingChar">
                            <div class="bg-slate-900 p-3 rounded-xl border border-slate-700 space-y-3 shadow-xl">
                                <!-- Character Header -->
                                <div class="flex justify-between items-center">
                                    <div class="flex items-center gap-3">
                                        <input x-model="editingChar.data.name" class="bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-sm outline-none focus:ring-1 focus:ring-blue-500" placeholder="Name">
                                        <span class="text-[10px] text-slate-500">Editing: <span x-text="editingChar._filename || 'New Character'"></span></span>
                                    </div>
                                </div>

                                <!-- Basic Fields -->
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                    <div>
                                        <label class="text-[9px] text-slate-500 font-black uppercase">Label Description</label>
                                        <textarea x-model="editingChar.data.extensions.label_description" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-[10px] h-12 outline-none focus:ring-1 focus:ring-blue-500" placeholder="Personal notes..."></textarea>
                                    </div>
                                    <div>
                                        <label class="text-[9px] text-slate-500 font-black uppercase">Danbooru Tag</label>
                                        <input x-model="editingChar.data.extensions.danbooru_tag" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-[10px] outline-none focus:ring-1 focus:ring-blue-500" placeholder="e.g. 1girl, blond hair...">
                                    </div>
                                </div>

                                <!-- AI-Assisted Editing Section -->
                                <div class="border-t border-slate-700 pt-3">
                                    <div class="flex justify-between items-center mb-2">
                                        <label class="text-[9px] text-blue-400 font-black uppercase">AI-Assisted Editing</label>
                                        <div class="flex gap-2">
                                            <select x-model="editContextMode" class="bg-slate-800 border border-slate-700 rounded-lg px-2 py-1 text-[10px] text-slate-300">
                                                <option value="chat">Use Current Chat</option>
                                                <option value="manual">Manual Input</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <template x-if="editContextMode === 'manual'">
                                        <div class="space-y-2 mb-3">
                                            <label class="text-[9px] text-slate-500 font-black uppercase">Context for AI</label>
                                            <textarea x-model="editContextText" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-[10px] h-16 outline-none focus:ring-1 focus:ring-blue-500" placeholder="Provide context for AI generation..."></textarea>
                                        </div>
                                    </template>

                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                                        <button @click="editFieldAI('personality')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingField">
                                            <i class="fa-solid mr-1" :class="isEditingField ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Personality
                                        </button>
                                        <button @click="editFieldAI('body')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingField">
                                            <i class="fa-solid mr-1" :class="isEditingField ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Body
                                        </button>
                                        <button @click="editFieldAI('scenario')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingField">
                                            <i class="fa-solid mr-1" :class="isEditingField ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Scenario
                                        </button>
                                        <button @click="editFieldAI('genre')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingField">
                                            <i class="fa-solid mr-1" :class="isEditingField ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Genre
                                        </button>
                                        <button @click="editFieldAI('tags')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingField">
                                            <i class="fa-solid mr-1" :class="isEditingField ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Tags
                                        </button>
                                        <button @click="editFieldAI('first_message')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingField">
                                            <i class="fa-solid mr-1" :class="isEditingField ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>First Message
                                        </button>
                                    </div>
                                </div>

                                <!-- Manual Editing Section -->
                                <div class="border-t border-slate-700 pt-3">
                                    <label class="text-[9px] text-slate-500 font-black uppercase mb-2 block">Manual Editing</label>
                                    
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                        <div>
                                            <label class="text-[9px] text-slate-500 font-black uppercase">Description/Dialogue</label>
                                            <textarea x-model="editingChar.data.description" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-xs h-24 outline-none focus:ring-1 focus:ring-blue-500" placeholder="Description/Example Dialogue"></textarea>
                                        </div>
                                        <div>
                                            <label class="text-[9px] text-slate-500 font-black uppercase">Reinforcement Prompt</label>
                                            <textarea x-model="editingChar.data.extensions.depth_prompt.prompt" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-xs h-24 outline-none focus:ring-1 focus:ring-blue-500" placeholder="Personality/Scenario..."></textarea>
                                        </div>
                                    </div>

                                    <!-- Multi-Character Capsule -->
                                    <div class="border-t border-slate-700 pt-3 mt-2">
                                        <div class="flex justify-between items-center mb-1">
                                            <label class="text-[9px] text-purple-400 font-black uppercase">Multi-Char Capsule</label>
                                            <div class="flex gap-2">
                                                <button @click="editCapsuleAI()" class="text-[8px] text-purple-400 hover:text-purple-300 font-bold uppercase" :disabled="isEditingCapsule">
                                                    <i class="fa-solid mr-1" :class="isEditingCapsule ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>AI Generate
                                                </button>
                                                <button @click="generateCapsule()" class="text-[8px] text-purple-400 hover:text-purple-300 font-bold uppercase" :disabled="isGeneratingCapsule">
                                                    <i class="fa-solid mr-1" :class="isGeneratingCapsule ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Auto Generate
                                                </button>
                                            </div>
                                        </div>
                                        <textarea x-model="editingChar.data.extensions.multi_char_summary" class="w-full bg-slate-950 border border-purple-900/50 rounded-lg px-2 py-1.5 text-[10px] h-16 outline-none focus:ring-1 focus:ring-purple-500" placeholder="Compact capsule for group chats..."></textarea>
                                        <p class="text-[8px] text-slate-600 mt-1">Used instead of full description when 2+ characters are active.</p>
                                    </div>
                                </div>

                                <!-- Fixed Save/Cancel Buttons for Small Screens -->
                                <div class="sticky bottom-0 bg-slate-900 border-t border-slate-700 p-3 -mx-3 -mb-3 rounded-b-xl">
                                    <div class="flex gap-2 justify-end">
                                        <button @click="saveCharacter()" class="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded-lg text-xs font-black uppercase shadow-lg shadow-green-900/20 transition-all">
                                            Save
                                        </button>
                                        <button @click="editingChar = null" class="bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg text-xs font-black uppercase transition-all">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </template>

                        <!-- Character List -->
                        <div class="space-y-2">
                            <template x-for="char in characters">
                                <div class="p-3 bg-slate-700/30 hover:bg-slate-700/60 rounded-xl cursor-pointer border border-transparent hover:border-slate-600 group flex justify-between items-center transition-all" :class="isCharacterActive(char) ? 'border-blue-500/50 bg-blue-500/10' : ''" @click="toggleCharacter(char)">
                                    <div class="flex flex-col flex-1 min-w-0">
                                        <div class="flex items-center gap-2">
                                            <div x-show="isCharacterActive(char)" class="w-1.5 h-1.5 rounded-full bg-blue-500 shadow-[0_0_5px_rgba(59,130,246,0.8)]"></div>
                                            <span class="font-bold text-sm" x-text="char.data?.name"></span>
                                            <span class="text-[10px] text-slate-500" x-text="char._filename"></span>
                                        </div>
                                        <span class="text-[10px] text-slate-500 truncate" x-text="char.data?.extensions?.label_description || char.data?.description"></span>
                                    </div>
                                    <div class="hidden group-hover:flex gap-1">
                                        <button @click.stop="startEditCharacter(char)" class="flex items-center justify-center w-6 h-6 rounded-lg bg-slate-800 hover:bg-blue-600 text-white transition-all" title="Edit Character">
                                            <i class="fa-solid fa-pen text-[10px]"></i>
                                        </button>
                                        <button @click.stop="deleteCharacter(char)" class="flex items-center justify-center w-6 h-6 rounded-lg bg-slate-800 hover:bg-red-600 text-white transition-all" title="Delete Character">
                                            <i class="fa-solid fa-trash text-[10px]"></i>
                                        </button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </template>

                <!-- World Info Sidebar -->
                <template x-if="showSidebar === 'world-info'">
                    <div class="space-y-4">
                        <div class="flex gap-2">
                            <div class="flex-1"></div>
                            <button @click="fetchWorldInfo()" class="bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded-lg text-slate-300" title="Refresh World Info"><i class="fa-solid fa-rotate"></i></button>
                        </div>
                        
                        <!-- World Info Editing Interface -->
                        <template x-if="editingWorldEntry">
                            <div class="bg-slate-900 p-3 rounded-xl border border-slate-700 space-y-3 shadow-xl">
                                <!-- World Info Header -->
                                <div class="flex justify-between items-center">
                                    <div class="flex items-center gap-3">
                                        <span class="font-bold text-sm" x-text="editingWorldEntry.world_name"></span>
                                        <span class="text-[10px] text-slate-500">Entry: <span x-text="editingWorldEntry.entry_uid || 'New Entry'"></span></span>
                                    </div>
                                </div>

                                <!-- Basic Fields -->
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                    <div>
                                        <label class="text-[9px] text-slate-500 font-black uppercase">Keys (comma-separated)</label>
                                        <input x-model="editingWorldEntry.entry.key" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-[10px] outline-none focus:ring-1 focus:ring-blue-500" placeholder="e.g. magic, spells, arcane">
                                    </div>
                                    <div>
                                        <label class="text-[9px] text-slate-500 font-black uppercase">Comment</label>
                                        <input x-model="editingWorldEntry.entry.comment" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-[10px] outline-none focus:ring-1 focus:ring-blue-500" placeholder="Optional comment">
                                    </div>
                                </div>

                                <!-- Content -->
                                <div>
                                    <label class="text-[9px] text-slate-500 font-black uppercase">Content</label>
                                    <textarea x-model="editingWorldEntry.entry.content" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-xs h-24 outline-none focus:ring-1 focus:ring-blue-500" placeholder="World lore entry content..."></textarea>
                                </div>

                                <!-- Flags -->
                                <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                                    <div class="flex items-center gap-2">
                                        <input type="checkbox" x-model="editingWorldEntry.entry.is_canon_law" class="w-4 h-4 text-red-600 bg-slate-900 border-slate-700 rounded focus:ring-red-500">
                                        <label class="text-[9px] text-slate-500 font-black uppercase">Canon Law</label>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="checkbox" x-model="editingWorldEntry.entry.useProbability" class="w-4 h-4 text-blue-600 bg-slate-900 border-slate-700 rounded focus:ring-blue-500">
                                        <label class="text-[9px] text-slate-500 font-black uppercase">Use Probability</label>
                                    </div>
                                    <div>
                                        <label class="text-[9px] text-slate-500 font-black uppercase">Probability</label>
                                        <input type="number" x-model.number="editingWorldEntry.entry.probability" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-[10px] outline-none focus:ring-1 focus:ring-blue-500" placeholder="0-100">
                                    </div>
                                </div>

                                <!-- AI-Assisted Editing Section -->
                                <div class="border-t border-slate-700 pt-3">
                                    <div class="flex justify-between items-center mb-2">
                                        <label class="text-[9px] text-blue-400 font-black uppercase">AI-Assisted Editing</label>
                                        <div class="flex gap-2">
                                            <select x-model="worldEditContextMode" class="bg-slate-800 border border-slate-700 rounded-lg px-2 py-1 text-[10px] text-slate-300">
                                                <option value="chat">Use Current Chat</option>
                                                <option value="manual">Manual Input</option>
                                            </select>
                                        </div>
                                    </div>
                                    
                                    <template x-if="worldEditContextMode === 'manual'">
                                        <div class="space-y-2 mb-3">
                                            <label class="text-[9px] text-slate-500 font-black uppercase">Context for AI</label>
                                            <textarea x-model="worldEditContextText" class="w-full bg-slate-800 border border-slate-700 rounded-lg px-2 py-1.5 text-[10px] h-16 outline-none focus:ring-1 focus:ring-blue-500" placeholder="Provide context for AI generation..."></textarea>
                                        </div>
                                    </template>

                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                                        <button @click="editWorldEntryAI('history')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingWorldEntry">
                                            <i class="fa-solid mr-1" :class="isEditingWorldEntry ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>History
                                        </button>
                                        <button @click="editWorldEntryAI('locations')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingWorldEntry">
                                            <i class="fa-solid mr-1" :class="isEditingWorldEntry ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Locations
                                        </button>
                                        <button @click="editWorldEntryAI('creatures')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingWorldEntry">
                                            <i class="fa-solid mr-1" :class="isEditingWorldEntry ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Creatures
                                        </button>
                                        <button @click="editWorldEntryAI('factions')" class="bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-blue-900/20" :disabled="isEditingWorldEntry">
                                            <i class="fa-solid mr-1" :class="isEditingWorldEntry ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Factions
                                        </button>
                                        <button @click="addWorldEntry()" class="bg-green-600 hover:bg-green-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-green-900/20" :disabled="isAddingWorldEntry">
                                            <i class="fa-solid mr-1" :class="isAddingWorldEntry ? 'fa-circle-notch fa-spin' : 'fa-plus'"></i>Add Entry
                                        </button>
                                        <button @click="deleteWorldEntry(editingWorldEntry.world_name, editingWorldEntry.entry_uid)" class="bg-red-600 hover:bg-red-500 text-white text-[10px] font-black uppercase px-2 py-1 rounded-lg shadow-lg shadow-red-900/20" :disabled="!editingWorldEntry.entry_uid">
                                            <i class="fa-solid mr-1" :class="isDeletingWorldEntry ? 'fa-circle-notch fa-spin' : 'fa-trash'"></i>Delete
                                        </button>
                                    </div>
                                </div>

                                <!-- Fixed Save/Cancel Buttons for World Info -->
                                <div class="sticky bottom-0 bg-slate-900 border-t border-slate-700 p-3 -mx-3 -mb-3 rounded-b-xl">
                                    <div class="flex gap-2 justify-end">
                                        <button @click="saveWorldEntry()" class="bg-green-600 hover:bg-green-500 text-white px-4 py-2 rounded-lg text-xs font-black uppercase shadow-lg shadow-green-900/20 transition-all">
                                            Save
                                        </button>
                                        <button @click="editingWorldEntry = null" class="bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg text-xs font-black uppercase transition-all">
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </template>

                        <!-- World Info List -->
                        <div class="space-y-2">
                            <template x-for="wi in worldInfos">
                                <div class="bg-slate-900/50 rounded-xl overflow-hidden border border-slate-700/50">
                                    <button @click="activeWI = activeWI?.name === wi.name ? null : wi" class="w-full text-left font-black text-[10px] tracking-widest uppercase p-3 transition-all hover:bg-slate-700/30 flex justify-between items-center" :class="activeWI?.name === wi.name ? 'text-green-400 bg-green-500/10' : 'text-slate-500'">
                                        <span x-text="wi.name"></span>
                                        <div class="flex items-center gap-2">
                                            <i class="fa-solid" :class="activeWI?.name === wi.name ? 'fa-chevron-up' : 'fa-chevron-down'"></i>
                                        </div>
                                    </button>
                                    <div x-show="activeWI?.name === wi.name" class="p-3 pt-0 space-y-3">
                                        <template x-for="(entry, uid) in wi.entries" :key="uid">
                                            <div class="p-2 bg-slate-800 rounded-lg border border-slate-700 transition-all hover:border-slate-600">
                                                <div class="flex justify-between items-start mb-1">
                                                    <div @click="toggleCanonLaw(wi, uid)" 
                                                         class="font-black text-[9px] uppercase tracking-widest cursor-pointer hover:opacity-80 transition-all" 
                                                         :class="entry.is_canon_law ? 'text-red-500' : 'text-green-500'"
                                                         x-text="entry.key.join(' â€¢ ')"></div>
                                                    <div class="flex gap-1 items-center">
                                                        <div x-show="entry.is_canon_law" class="text-[7px] bg-red-500/20 text-red-500 px-1 rounded uppercase font-black">Canon Law</div>
                                                        <div x-show="entry.constant" class="text-[8px] bg-green-500/20 text-green-400 px-1 rounded uppercase font-black">Constant</div>
                                                        <div class="flex gap-1 mt-2">
                                                            <button @click="startEditWorldEntry(wi, uid)" class="text-[8px] text-blue-400 hover:text-blue-300 font-bold uppercase px-2 py-1 rounded-lg border border-blue-500/30 hover:border-blue-400/50 transition-all" title="Edit Entry">
                                                                <i class="fa-solid fa-pen mr-1"></i>Edit
                                                            </button>
                                                            <button @click="deleteWorldEntry(wi.name, uid)" class="text-[8px] text-red-400 hover:text-red-300 font-bold uppercase px-2 py-1 rounded-lg border border-red-500/30 hover:border-red-400/50 transition-all" title="Delete Entry">
                                                                <i class="fa-solid fa-trash mr-1"></i>Delete
                                                            </button>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="text-[10px] text-slate-400 leading-tight line-clamp-3 font-medium" x-text="entry.content"></div>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </template>

                <!-- Settings Sidebar -->
                <template x-if="showSidebar === 'settings'">
                    <div class="space-y-6">
                        <div class="space-y-4 pt-2">
                            <h3 class="text-[10px] font-black uppercase tracking-widest text-slate-500">Neural Connection</h3>
                            
                            <!-- Connection Status Indicators -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                <div class="bg-slate-900/50 rounded-xl p-3 border border-slate-700/50">
                                    <div class="flex justify-between items-center mb-2">
                                        <div class="flex items-center gap-2">
                                            <div class="w-2 h-2 rounded-full" :class="getServiceStatusClass('kobold')"></div>
                                            <span class="text-[9px] font-black uppercase text-slate-400">KoboldCpp</span>
                                        </div>
                                        <button @click="testConnection('kobold')" class="text-[8px] text-slate-500 hover:text-slate-300 font-bold uppercase" :disabled="isCheckingConnections">
                                            <i class="fa-solid mr-1" :class="isCheckingConnections ? 'fa-circle-notch fa-spin' : 'fa-refresh'"></i>Test
                                        </button>
                                    </div>
                                    <div class="text-[8px] text-slate-500 leading-tight" x-text="getServiceStatusText('kobold')"></div>
                                    <div class="mt-1 text-[7px] text-slate-600" x-text="config.kobold_url"></div>
                                </div>
                                
                                <div class="bg-slate-900/50 rounded-xl p-3 border border-slate-700/50">
                                    <div class="flex justify-between items-center mb-2">
                                        <div class="flex items-center gap-2">
                                            <div class="w-2 h-2 rounded-full" :class="getServiceStatusClass('sd')"></div>
                                            <span class="text-[9px] font-black uppercase text-slate-400">Stable Diffusion</span>
                                        </div>
                                        <button @click="testConnection('sd')" class="text-[8px] text-slate-500 hover:text-slate-300 font-bold uppercase" :disabled="isCheckingConnections">
                                            <i class="fa-solid mr-1" :class="isCheckingConnections ? 'fa-circle-notch fa-spin' : 'fa-refresh'"></i>Test
                                        </button>
                                    </div>
                                    <div class="text-[8px] text-slate-500 leading-tight" x-text="getServiceStatusText('sd')"></div>
                                    <div class="mt-1 text-[7px] text-slate-600" x-text="config.sd_url"></div>
                                </div>
                            </div>

                            <div class="space-y-3">
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">System Prompt</label>
                                    <textarea x-model="settings.system_prompt" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-xs h-24 outline-none focus:ring-1 focus:ring-blue-500"></textarea>
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">Your Persona (You)</label>
                                    <textarea x-model="settings.user_persona" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-xs h-24 outline-none focus:ring-1 focus:ring-blue-500" placeholder="Describe your character..."></textarea>
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">Reinforce Character Info Every X Turns</label>
                                    <input type="number" x-model.number="settings.reinforce_freq" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-blue-500">
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">Reinforce World Canon Every X Turns</label>
                                    <input type="number" x-model.number="settings.world_info_reinforce_freq" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-blue-500" placeholder="3">
                                    <p class="text-[8px] text-slate-500 leading-tight">Frequency for reinforcing world canon law entries (1-100, 0 to disable)</p>
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">Enable World Info</label>
                                    <div class="flex items-center gap-3">
                                        <input type="checkbox" x-model="settings.world_info_enabled" class="w-4 h-4 text-blue-600 bg-slate-900 border-slate-700 rounded focus:ring-blue-500">
                                        <span class="text-[9px] text-slate-500">Include world lore in prompts</span>
                                    </div>
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">Max World Info Entries</label>
                                    <div class="flex items-center gap-3">
                                        <input type="number" x-model.number="settings.max_world_info_entries" class="w-24 bg-slate-900 border border-slate-700 rounded-lg p-1 text-xs outline-none focus:ring-1 focus:ring-blue-500" placeholder="10">
                                        <span class="text-[9px] text-slate-500">0 = unlimited</span>
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-3">
                                    <div class="space-y-1">
                                        <label class="text-[10px] text-slate-450 uppercase font-bold">Temperature</label>
                                        <input type="number" step="0.1" x-model.number="settings.temperature" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-blue-500">
                                    </div>
                                    <div class="space-y-1">
                                        <label class="text-[10px] text-slate-450 uppercase font-bold">Max Resp Tokens</label>
                                        <input type="number" x-model.number="settings.max_length" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-blue-500">
                                    </div>
                                </div>
                                <div class="grid grid-cols-2 gap-3">
                                    <div class="space-y-1">
                                        <label class="text-[10px] text-slate-450 uppercase font-bold">Max Context</label>
                                        <input type="number" x-model.number="settings.max_context" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-blue-500">
                                    </div>
                                    <div class="space-y-1">
                                        <label class="text-[10px] text-slate-450 uppercase font-bold">Summ Threshold</label>
                                        <input type="number" step="0.01" x-model.number="settings.summarize_threshold" class="w-full bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-blue-500">
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Current Summary View -->
                        <div x-show="summary" class="space-y-2 pt-4 border-t border-slate-700">
                            <h3 class="text-[10px] font-black uppercase tracking-widest text-slate-500">Long-Term Memory</h3>
                            <textarea x-model="summary" class="w-full bg-slate-950/50 border border-slate-700 rounded-lg p-2 text-[10px] h-32 text-slate-400 outline-none focus:ring-1 focus:ring-blue-500/30" readonly></textarea>
                            <button @click="if(confirm('Clear long-term memory?')) summary = ''" class="text-[8px] text-red-400 uppercase font-bold tracking-widest hover:text-red-300 transition-colors">Clear Memory</button>
                        </div>

                        <div class="space-y-4 pt-4 border-t border-slate-700">
                            <h3 class="text-[10px] font-black uppercase tracking-widest text-slate-500">Performance Optimization</h3>
                            <div class="space-y-3">
                                <div class="space-y-1">
                                    <div class="flex items-center justify-between">
                                        <label class="text-[10px] text-slate-450 uppercase font-bold">Smart Performance Mode</label>
                                        <input type="checkbox" x-model="settings.performance_mode_enabled" @change="togglePerformanceMode()" class="w-4 h-4 text-green-600 bg-slate-900 border-slate-700 rounded focus:ring-green-500">
                                    </div>
                                    <p class="text-[8px] text-slate-500 leading-tight">Intelligently queues LLM/SD operations and optimizes image generation based on context size</p>
                                </div>
                            </div>
                        </div>

                        <!-- World Info Cache Management -->
                        <div class="space-y-4 pt-4 border-t border-slate-700">
                            <h3 class="text-[10px] font-black uppercase tracking-widest text-slate-500">World Info Cache</h3>
                            <div class="space-y-3">
                                <div class="bg-slate-900/50 rounded-xl p-3 border border-slate-700/50">
                                    <div class="flex justify-between items-center mb-2">
                                        <div class="text-[9px] font-black uppercase text-slate-400">Cache Status</div>
                                        <div class="flex gap-2">
                                            <button @click="fetchCacheStats()" class="text-[8px] text-slate-500 hover:text-slate-300 font-bold uppercase" :disabled="isFetchingCache">
                                                <i class="fa-solid mr-1" :class="isFetchingCache ? 'fa-circle-notch fa-spin' : 'fa-refresh'"></i>Refresh
                                            </button>
                                            <button @click="clearCache()" class="text-[8px] text-red-400 hover:text-red-300 font-bold uppercase" :disabled="isClearingCache">
                                                <i class="fa-solid mr-1" :class="isClearingCache ? 'fa-circle-notch fa-spin' : 'fa-trash'"></i>Clear
                                            </button>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-2 gap-2 text-[8px] text-slate-500">
                                        <div>Entries: <span x-text="cacheStats.size || '0'"></span></div>
                                        <div>Max: <span x-text="cacheStats.max_size || '1000'"></span></div>
                                        <div>Usage: <span x-text="(cacheStats.usage_percent || 0).toFixed(1) + '%'"></span></div>
                                        <div>Memory: <span x-text="((cacheStats.size || 0) * 2).toFixed(1) + ' KB (est.)'"></span></div>
                                    </div>
                                    <div class="mt-2 w-full bg-slate-800 rounded-full h-1.5">
                                        <div class="bg-green-500 h-1.5 rounded-full" :style="'width: ' + (cacheStats.usage_percent || 0) + '%'"></div>
                                    </div>
                                </div>
                                
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">Cache Size Limit</label>
                                    <div class="flex gap-2">
                                        <input type="number" x-model.number="cacheConfig.max_size" class="w-24 bg-slate-900 border border-slate-700 rounded-lg p-1 text-xs outline-none focus:ring-1 focus:ring-blue-500" placeholder="1000">
                                        <button @click="updateCacheConfig()" class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded-lg text-[10px] font-black uppercase tracking-widest shadow-lg shadow-blue-900/20 transition-all" :disabled="isUpdatingCache">
                                            <span x-show="!isUpdatingCache">Update</span>
                                            <i x-show="isUpdatingCache" class="fa-solid fa-circle-notch fa-spin"></i>
                                        </button>
                                    </div>
                                    <p class="text-[8px] text-slate-500 leading-tight">Maximum number of cached world info entries (0 = unlimited)</p>
                                </div>
                            </div>
                        </div>

                        <div class="space-y-4 pt-4 border-t border-slate-700">
                            <h3 class="text-[10px] font-black uppercase tracking-widest text-slate-500">API Configuration</h3>
                            <div class="space-y-3">
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">Kobold URL</label>
                                    <div class="flex gap-2">
                                        <input x-model="config.kobold_url" class="flex-1 bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-blue-500">
                                        <button @click="updateAPIURLs()" class="bg-blue-600 hover:bg-blue-500 text-white px-3 py-2 rounded-lg text-[10px] font-black uppercase tracking-widest shadow-lg shadow-blue-900/20 transition-all" :disabled="isCheckingConnections">
                                            <span x-show="!isCheckingConnections">Update & Test</span>
                                            <i x-show="isCheckingConnections" class="fa-solid fa-circle-notch fa-spin"></i>
                                        </button>
                                    </div>
                                </div>
                                <div class="space-y-1">
                                    <label class="text-[10px] text-slate-450 uppercase font-bold">SD API URL</label>
                                    <div class="flex gap-2">
                                        <input x-model="config.sd_url" class="flex-1 bg-slate-900 border border-slate-700 rounded-lg p-2 text-sm outline-none focus:ring-1 focus:ring-purple-500">
                                        <button @click="updateAPIURLs()" class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-2 rounded-lg text-[10px] font-black uppercase tracking-widest shadow-lg shadow-purple-900/20 transition-all" :disabled="isCheckingConnections">
                                            <span x-show="!isCheckingConnections">Update & Test</span>
                                            <i x-show="isCheckingConnections" class="fa-solid fa-circle-notch fa-spin"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col min-w-0 relative">
            <!-- Header -->
            <div class="h-14 border-b border-slate-700 flex items-center justify-between px-6 bg-slate-800/80 backdrop-blur shrink-0 z-10">
                <div class="flex gap-6">
                    <button @click="showSidebar = 'chats'" class="hover:text-green-400 flex items-center gap-2.5 text-xs font-black uppercase tracking-widest transition-all" :class="showSidebar === 'chats' ? 'text-green-400' : 'text-slate-400'">
                        <i class="fa-solid fa-message text-sm"></i><span class="hidden sm:inline">Chats</span>
                    </button>
                    <button @click="showSidebar = 'characters'" class="hover:text-blue-400 flex items-center gap-2.5 text-xs font-black uppercase tracking-widest transition-all" :class="showSidebar === 'characters' ? 'text-blue-400' : 'text-slate-400'">
                        <i class="fa-solid fa-users text-sm"></i><span class="hidden sm:inline">Characters</span>
                    </button>
                    <button @click="showSidebar = 'world-info'" class="hover:text-green-400 flex items-center gap-2.5 text-xs font-black uppercase tracking-widest transition-all" :class="showSidebar === 'world-info' ? 'text-green-400' : 'text-slate-400'">
                        <i class="fa-solid fa-earth-americas text-sm"></i><span class="hidden sm:inline">World Info</span>
                    </button>
                    <button @click="openCardGen()" class="hover:text-purple-400 flex items-center gap-2.5 text-xs font-black uppercase tracking-widest transition-all text-slate-400">
                        <i class="fa-solid fa-id-card text-sm"></i><span class="hidden sm:inline">Gen Card</span>
                    </button>
                    <button @click="openWorldGen()" class="hover:text-orange-400 flex items-center gap-2.5 text-xs font-black uppercase tracking-widest transition-all text-slate-400">
                        <i class="fa-solid fa-earth-europe text-sm"></i><span class="hidden sm:inline">Gen World</span>
                    </button>
                </div>
                <!-- Active Character Indicator -->
                <div class="flex-1 flex justify-center overflow-hidden mx-4 text-center">
                    <div x-show="activeCharacters.length > 0" class="flex items-center gap-2 overflow-x-auto no-scrollbar py-1" x-cloak x-transition>
                        <template x-for="char in activeCharacters" :key="char.data.name">
                            <div class="flex items-center gap-2 bg-slate-950/50 px-3 py-1 rounded-full text-[9px] border border-slate-700/50 shadow-inner whitespace-nowrap shrink-0">
                                <span class="w-1.5 h-1.5 rounded-full bg-green-500 shadow-[0_0_6px_rgba(34,197,94,0.5)]"></span>
                                <span class="font-black tracking-wide uppercase" x-text="char.data?.name"></span>
                                <button @click="toggleCharacter(char)" class="text-slate-500 hover:text-red-400 ml-1 transition-all"><i class="fa-solid fa-xmark"></i></button>
                            </div>
                        </template>
                    </div>
                    <div x-show="activeCharacters.length === 0" class="flex items-center gap-2.5 bg-slate-950/50 px-4 py-1.5 rounded-full text-xs border border-slate-700/50 shadow-inner" x-cloak x-transition>
                        <span class="w-2 h-2 rounded-full bg-blue-500 shadow-[0_0_8px_rgba(59,130,246,0.5)]"></span>
                        <span class="font-black tracking-wide uppercase text-[10px]">Narrator Mode</span>
                    </div>
                </div>
                <button @click="showSidebar = 'settings'" class="text-slate-400 hover:text-slate-200 transition-all" :class="showSidebar === 'settings' ? 'text-blue-400' : ''">
                    <i class="fa-solid fa-sliders text-sm"></i>
                </button>
            </div>

            <!-- Chat Area -->
            <div id="chat-container" class="flex-1 overflow-y-auto p-6 space-y-8 bg-slate-900 border-x border-slate-800/50 w-full">
                <template x-if="messages.length === 0">
                    <div class="h-full flex flex-col items-center justify-center text-slate-600 space-y-6 opacity-50">
                        <div class="w-20 h-20 rounded-3xl bg-slate-800/50 border border-slate-700 flex items-center justify-center shadow-2xl">
                            <span class="text-3xl rotate-12">*-*</span>
                        </div>
                        <div class="text-center group">
                            <p class="text-[10px] font-black uppercase tracking-[0.3em] mb-1 group-hover:text-blue-500 transition-colors">Neural Connection Ready</p>
                            <p class="text-[9px] font-medium text-slate-500">Awaiting user input or vision sequence</p>
                        </div>
                    </div>
                </template>
                <div class="space-y-8">
                    <template x-for="(msg, index) in messages" :key="msg.id">
                        <div class="flex group" :class="msg.role === 'user' ? 'justify-end' : 'justify-start'">
                            <div class="max-w-[85%] space-y-1.5 relative" :style="editingMessageId === msg.id && editingWidth ? 'min-width: ' + editingWidth : ''">
                                <div x-show="msg.role !== 'user' && msg.speaker !== 'Visual System'" class="text-[9px] font-black text-blue-500 uppercase tracking-[0.2em] ml-4 mb-1" x-text="msg.speaker || 'Narrator'"></div>
                                
                                <div class="relative px-5 py-3.5 shadow-xl transition-all border border-transparent" :class="msg.role === 'user' ? 'bg-blue-600 text-white rounded-3xl rounded-tr-[4px] shadow-blue-900/20' : 'bg-slate-800 border border-slate-700/50 text-slate-200 rounded-3xl rounded-tl-[4px] shadow-black/20 hover:border-slate-600'" :style="msg.speaker === 'Visual System' ? 'padding: 0; background: transparent; border: none; box-shadow: none;' : ''">
                                    
                                    <!-- Message Controls -->
                                    <div class="absolute -top-3 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-all z-10 h-6">
                                        <template x-if="msg.role === 'user'">
                                            <button @click="regenerate(index)" class="w-6 h-6 rounded-full bg-slate-700 hover:bg-green-600 text-white flex items-center justify-center shadow-lg border border-slate-600 border-opacity-50" title="Regenerate from here"><i class="fa-solid fa-rotate text-[8px]"></i></button>
                                        </template>
                                        <button @click="openForkDialog(msg.id)" class="w-6 h-6 rounded-full bg-slate-700 hover:bg-blue-600 text-white flex items-center justify-center shadow-lg border border-slate-600 border-opacity-50" title="Fork from here"><i class="fa-solid fa-code-branch text-[8px]"></i></button>
                                        <button @click="editingMessageId = msg.id; editBuffer = msg.content; editingWidth = $el.closest('.max-w-\\[85\\%\\]').offsetWidth + 'px'" class="w-6 h-6 rounded-full bg-slate-700 hover:bg-blue-600 text-white flex items-center justify-center shadow-lg border border-slate-600 border-opacity-50"><i class="fa-solid fa-pen text-[8px]"></i></button>
                                        <button @click="deleteMessage(index)" class="w-6 h-6 rounded-full bg-slate-700 hover:bg-red-600 text-white flex items-center justify-center shadow-lg border border-slate-600 border-opacity-50"><i class="fa-solid fa-trash text-[8px]"></i></button>
                                        <template x-if="msg.image">
                                            <button @click="copyImageSettings(msg.image)" class="w-6 h-6 rounded-full bg-slate-700 hover:bg-purple-600 text-white flex items-center justify-center shadow-lg border border-slate-600 border-opacity-50" title="Copy Image Settings"><i class="fa-solid fa-copy text-[8px]"></i></button>
                                        </template>
                                        <template x-if="msg.image">
                                            <button @click="openInpaintDialog(msg, index)" class="w-6 h-6 rounded-full bg-slate-700 hover:bg-orange-600 text-white flex items-center justify-center shadow-lg border border-slate-600 border-opacity-50" title="Inpaint Image"><i class="fa-solid fa-paintbrush text-[8px]"></i></button>
                                        </template>
                                    </div>

                                    <template x-if="editingMessageId !== msg.id">
                                        <div>
                                            <div x-show="msg.content" class="whitespace-pre-wrap leading-relaxed text-[13px] font-medium" x-text="msg.content"></div>
                                            <template x-if="msg.image">
                                                <div :class="msg.content ? 'mt-3 -mx-2' : ''">
                                                    <a :href="msg.image" target="_blank">
                                                        <img :src="msg.image" class="rounded-2xl border border-slate-700/50 max-w-full shadow-2xl hover:brightness-110 transition-all cursor-zoom-in">
                                                    </a>
                                                </div>
                                            </template>
                                        </div>
                                    </template>

                                    <!-- Edit Interface -->
                                    <template x-if="editingMessageId === msg.id">
                                        <div class="space-y-3">
                                            <textarea 
                                                x-model="editBuffer" 
                                                x-ref="editTextarea"
                                                @input="$el.style.height = 'auto'; $el.style.height = $el.scrollHeight + 'px'"
                                                x-init="$nextTick(() => { $el.style.height = 'auto'; $el.style.height = $el.scrollHeight + 'px'; })"
                                                class="w-full bg-slate-900/50 text-slate-100 outline-none text-[13px] font-medium leading-relaxed resize-none min-h-[100px] max-h-[600px] overflow-y-auto border border-slate-600/30 rounded-lg p-3 focus:border-blue-500/50 transition-colors"
                                                placeholder="Edit your message..."></textarea>
                                            <div class="flex gap-2 justify-end">
                                                <button @click="updateMessage(index)" class="px-3 py-1 bg-blue-500 hover:bg-blue-400 text-white text-[10px] font-black uppercase tracking-widest rounded-lg transition-all">Update</button>
                                                <button @click="editingMessageId = null; editingWidth = null" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 text-white text-[10px] font-black uppercase tracking-widest rounded-lg transition-all">Cancel</button>
                                            </div>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                    <div x-show="isLoading" class="flex justify-start" x-cloak>
                        <div class="bg-slate-800/50 border border-slate-700/50 rounded-2xl rounded-tl-[4px] px-5 py-4">
                            <div class="flex gap-2 item-center">
                                <div class="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce"></div>
                                <div class="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                                <div class="w-1.5 h-1.5 bg-blue-500 rounded-full animate-bounce" style="animation-delay: 0.4s"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Image Generator (Collapsible) -->
            <div class="bg-slate-800 border-t border-slate-700 transition-all duration-500 ease-in-out overflow-hidden z-20 shadow-2xl shrink-0" :class="showImagePanel ? 'max-h-[500px]' : 'max-h-0 border-transparent'">
                <div class="p-6 space-y-6 w-full">
                    <div class="flex flex-col md:flex-row gap-6">
                        <div class="flex-1">
                            <label class="text-[9px] text-slate-500 uppercase font-black mb-2 block tracking-widest">Vision Input</label>
                            <textarea x-model="sdParams.prompt" class="w-full bg-slate-900 border border-slate-700 rounded-2xl p-4 text-xs h-28 resize-none focus:ring-2 focus:ring-purple-500/30 outline-none transition-all font-mono leading-relaxed" placeholder="Prompt..."></textarea>
                        </div>
                        <div class="flex-1">
                            <label class="text-[9px] text-slate-500 uppercase font-black mb-2 block tracking-widest">Negative Prompt</label>
                            <textarea x-model="sdParams.negative_prompt" class="w-full bg-slate-950 border border-slate-700 rounded-2xl p-4 text-xs h-28 resize-none focus:ring-2 focus:ring-red-500/30 outline-none transition-all font-mono leading-relaxed" placeholder="Omit..."></textarea>
                        </div>
                    </div>
                    <div class="flex flex-wrap items-center gap-8 pt-4 border-t border-slate-700/50">
                        <div class="flex gap-6 text-center">
                            <div class="flex flex-col gap-1.5">
                                <label class="text-[8px] text-slate-500 uppercase font-black tracking-widest">Steps</label>
                                <input type="number" x-model.number="sdParams.steps" class="w-16 bg-slate-950 border border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-purple-500 font-bold">
                            </div>
                            <div class="flex flex-col gap-1.5">
                                <label class="text-[8px] text-slate-500 uppercase font-black tracking-widest">Scale</label>
                                <input type="number" step="0.5" x-model.number="sdParams.cfg_scale" class="w-16 bg-slate-950 border border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-purple-500 font-bold">
                            </div>
                            <div class="flex flex-col gap-1.5">
                                <label class="text-[8px] text-slate-500 uppercase font-black tracking-widest">Resolution</label>
                                <div class="flex items-center gap-2">
                                    <input type="number" x-model.number="sdParams.width" class="w-16 bg-slate-950 border border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-purple-500 font-bold">
                                    <span class="text-slate-600 text-[10px] font-black">Ã—</span>
                                    <input type="number" x-model.number="sdParams.height" class="w-16 bg-slate-950 border border-slate-700 rounded-lg px-2 py-1.5 text-xs outline-none focus:border-purple-500 font-bold">
                                </div>
                            </div>
                        </div>
                        <div class="flex-1 flex justify-end">
                            <button @click="generateImage()" class="bg-purple-600 hover:bg-purple-500 text-white px-8 py-3 rounded-2xl text-xs font-black uppercase tracking-[0.2em] shadow-xl shadow-purple-900/40 transition-all active:scale-95 disabled:opacity-50 flex items-center gap-3" :disabled="isLoading">
                                <span x-show="!isLoading">Generate Vision Sequence</span>
                                <span x-show="isLoading">Generating...</span>
                                <i class="fa-solid" :class="isLoading ? 'fa-spinner fa-spin' : 'fa-wand-magic-sparkles'"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="p-6 bg-slate-800 border-t border-slate-700 flex flex-col gap-2 shrink-0 z-10 shadow-[0_-10px_30px_-5px_rgba(0,0,0,0.3)]">
                <!-- Token Counter Display -->
                <div class="flex justify-between items-center px-4">
                    <div class="text-[9px] font-black tracking-widest uppercase text-slate-500 flex items-center gap-2">
                        <span :class="tokenCount > settings.max_context * 0.85 ? 'text-orange-500' : 'text-slate-500'">Context: <span x-text="tokenCount">0</span> / <span x-text="settings.max_context">4096</span></span>
                        <template x-if="isCountingTokens">
                            <i class="fa-solid fa-circle-notch fa-spin text-blue-500"></i>
                        </template>
                    </div>
                    <button @click="updateTokenCount()" class="text-[9px] font-bold text-blue-400 hover:text-blue-300 transition-colors uppercase tracking-tight">Manual Refresh</button>
                </div>
                
                <div class="flex gap-4 items-end">
                    <button @click="showImagePanel = !showImagePanel" 
                            class="p-4 rounded-2xl transition-all relative group shadow-lg shadow-black/20" 
                            :class="showImagePanel ? 'bg-purple-600 text-white shadow-purple-900/40' : 'bg-slate-700/50 text-slate-400 hover:bg-slate-700 hover:text-slate-200'"
                            :disabled="!canGenerateImages() || isLoading">
                        <i class="fa-solid fa-wand-magic-sparkles text-lg group-hover:scale-110 transition-transform" :class="!canGenerateImages() ? 'opacity-50' : ''"></i>
                        <div x-show="!canGenerateImages()" class="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full shadow-lg shadow-red-900/40"></div>
                    </button>
                    
                    <!-- Mode Selector Dropdown -->
                    <div class="relative">
                        <select x-model="selectedMode" 
                                class="appearance-none bg-slate-700/50 border border-slate-600 text-slate-300 rounded-2xl px-4 py-3 pr-10 text-[10px] font-bold uppercase tracking-widest outline-none focus:ring-2 focus:ring-blue-500/30 cursor-pointer shadow-lg shadow-black/20 hover:bg-slate-700 transition-all"
                                :class="isClassifyingMode ? 'opacity-50' : ''"
                                :disabled="!canGenerateText()">
                            <option value="auto">ðŸ¤– Auto</option>
                            <option value="narrator">ðŸŽ­ Narrator</option>
                            <template x-for="char in activeCharacters" :key="char.data.name">
                                <option :value="'focus:' + char.data.name" x-text="'ðŸ‘¤ ' + char.data.name"></option>
                            </template>
                        </select>
                        <div class="absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none text-slate-500">
                            <i class="fa-solid fa-chevron-down text-[8px]" x-show="!isClassifyingMode"></i>
                            <i class="fa-solid fa-circle-notch fa-spin text-[10px] text-blue-400" x-show="isClassifyingMode"></i>
                        </div>
                        <div x-show="!canGenerateText()" class="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full shadow-lg shadow-red-900/40"></div>
                    </div>
                    
                    <div class="flex-1 relative group">
                        <textarea x-model="input" 
                                  @keydown.enter.prevent="if(!$event.shiftKey) sendMessage()" 
                                  class="w-full bg-slate-950/50 border border-slate-700 rounded-[24px] p-4 pr-14 max-h-44 resize-none focus:ring-2 focus:ring-blue-500/20 border-slate-700/50 outline-none text-[13px] font-medium leading-relaxed transition-all shadow-inner" 
                                  :placeholder="activeCharacters.length > 0 ? 'Chatting with party...' : 'Input neural prompt...'" 
                                  :disabled="!canGenerateText() || isLoading"
                                  rows="1"></textarea>
                        <button @click="sendMessage()" 
                                class="absolute right-2.5 bottom-2.5 p-3 bg-blue-600 hover:bg-blue-500 rounded-2xl text-white shadow-xl shadow-blue-900/40 disabled:opacity-20 transition-all active:scale-90" 
                                :disabled="!input.trim() || isLoading || !canGenerateText()">
                            <i class="fa-solid fa-paper-plane"></i>
                        </button>
                        <div x-show="!canGenerateText()" class="absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full shadow-lg shadow-red-900/40"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Fork Dialog Modal -->
    <div x-show="showForkDialog" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-950/80 backdrop-blur-sm" x-cloak x-transition>
        <div class="bg-slate-900 border border-slate-700 w-full max-w-md rounded-3xl shadow-2xl overflow-hidden">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                <h2 class="text-xs font-black uppercase tracking-widest text-blue-400">Create Branch</h2>
                <button @click="showForkDialog = false" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="p-6 space-y-4">
                <div class="space-y-2">
                    <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">Branch Name</label>
                    <input x-model="forkBranchName" class="w-full bg-slate-950 border border-slate-700 rounded-xl px-4 py-2 text-sm outline-none focus:ring-2 focus:ring-blue-500/30" placeholder="e.g. 'Accepted the deal' or 'Refused the deal'">
                </div>
                
                <div class="text-[9px] text-slate-500 leading-relaxed">
                    <p class="font-bold mb-1">Forking creates a new independent chat session</p>
                    <p>This branch will start from the selected message and maintain all current context (characters, world info, settings).</p>
                </div>
            </div>

            <div class="p-4 border-t border-slate-700 bg-slate-800/30 flex gap-3">
                <button @click="createFork()" class="flex-1 bg-blue-600 hover:bg-blue-500 text-white py-3 rounded-2xl text-[11px] font-black uppercase tracking-widest shadow-lg shadow-blue-900/20 transition-all" :disabled="!forkBranchName || isForking">
                    <span x-show="!isForking">Create Branch</span>
                    <span x-show="isForking">Creating...</span>
                </button>
                <button @click="showForkDialog = false" class="px-6 bg-slate-700 hover:bg-slate-600 text-white rounded-2xl text-[11px] font-black uppercase tracking-widest transition-all">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Branch Management Dialog -->
    <div x-show="showBranchDialog" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-950/80 backdrop-blur-sm" x-cloak x-transition>
        <div class="bg-slate-900 border border-slate-700 w-full max-w-2xl rounded-3xl shadow-2xl overflow-hidden flex flex-col max-h-[80vh]">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                <h2 class="text-xs font-black uppercase tracking-widest text-blue-400">Branch Management</h2>
                <button @click="showBranchDialog = false" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6 space-y-4">
                <div class="text-[9px] text-slate-500 font-bold uppercase tracking-widest">Active Branches</div>
                <template x-if="currentChatBranches.length === 0">
                    <div class="text-[10px] text-slate-500 text-center py-8">No branches found for this chat.</div>
                </template>
                <template x-for="branch in currentChatBranches" :key="branch.name">
                    <div class="flex items-center justify-between p-3 bg-slate-800 rounded-xl border border-slate-700/50">
                        <div class="flex-1">
                            <div class="font-bold text-sm" x-text="branch.branch_name || branch.name"></div>
                            <div class="text-[9px] text-slate-500" x-text="'Created ' + formatTime(branch.created_at)"></div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="loadChat(branch.name)" class="px-3 py-1 bg-blue-600 hover:bg-blue-500 text-white text-[10px] font-black uppercase tracking-widest rounded-lg">Switch</button>
                            <button @click="renameBranchDialog(branch)" class="px-3 py-1 bg-yellow-600 hover:bg-yellow-500 text-white text-[10px] font-black uppercase tracking-widest rounded-lg">Rename</button>
                            <button @click="deleteChat(branch.name)" class="px-3 py-1 bg-red-600 hover:bg-red-500 text-white text-[10px] font-black uppercase tracking-widest rounded-lg">Delete</button>
                        </div>
                    </div>
                </template>
            </div>

            <div class="p-4 border-t border-slate-700 bg-slate-800/30 flex gap-3">
                <button @click="showBranchDialog = false" class="px-6 bg-slate-700 hover:bg-slate-600 text-white rounded-2xl text-[11px] font-black uppercase tracking-widest transition-all">Close</button>
            </div>
        </div>
    </div>

    <!-- Inpaint Dialog Modal -->
    <div x-show="showInpaintDialog" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-950/80 backdrop-blur-sm" x-cloak x-transition>
        <div class="bg-slate-900 border border-slate-700 w-full max-w-6xl rounded-3xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh]">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                <h2 class="text-xs font-black uppercase tracking-widest text-orange-400">Inpaint Image</h2>
                <button @click="closeInpaintDialog()" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <!-- Inpaint Prompt -->
                <div class="space-y-2">
                    <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">Inpaint Prompt</label>
                    <textarea x-model="inpaintPrompt" class="w-full bg-slate-950 border border-slate-700 rounded-xl p-4 text-xs h-24 outline-none focus:ring-2 focus:ring-orange-500/30 font-medium leading-relaxed" placeholder="Describe what you want to paint in the masked area..."></textarea>
                </div>

                <!-- Denoising Strength Slider -->
                <div class="space-y-2 bg-slate-800/50 rounded-xl p-4 border border-slate-700/50">
                    <div class="flex justify-between items-center">
                        <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">Denoising Strength</label>
                        <span class="text-sm font-bold text-orange-400" x-text="inpaintDenoisingStrength.toFixed(2)"></span>
                    </div>
                    <input type="range" x-model.number="inpaintDenoisingStrength" min="0" max="1" step="0.05" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-orange-500">
                    <div class="flex justify-between text-[8px] text-slate-500 uppercase font-bold">
                        <span>0 = Keep Original</span>
                        <span>0.5 = Balanced</span>
                        <span>1 = Full Inpaint</span>
                    </div>
                    <p class="text-[8px] text-slate-400 leading-relaxed mt-1">
                        <i class="fa-solid fa-info-circle mr-1 text-orange-400/70"></i>
                        Lower values preserve more of the original image. Higher values give the AI more creative freedom in the masked area.
                    </p>
                </div>

                <!-- Canvas Container -->
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                        <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">Draw Mask (Brush over areas to inpaint)</label>
                        <div class="flex items-center gap-3">
                            <span class="text-[9px] text-slate-500 uppercase font-bold">Brush Size:</span>
                            <input type="range" x-model.number="brushSize" min="5" max="100" step="5" class="w-32">
                            <span class="text-[9px] text-slate-400 font-mono" x-text="brushSize + 'px'"></span>
                        </div>
                    </div>
                    
                    <div class="relative bg-slate-950 rounded-xl border border-slate-700 overflow-auto" style="max-height: 60vh;">
                        <div class="relative inline-block">
                            <!-- Original Image -->
                            <img :src="inpaintImageUrl" 
                                 id="inpaint-image"
                                 class="block"
                                 @load="initializeInpaintCanvas()"
                                 style="max-width: none;">
                            
                            <!-- Canvas Overlay for drawing -->
                            <canvas id="inpaint-canvas"
                                    class="absolute top-0 left-0 cursor-crosshair"
                                    @mousedown="startDrawing($event)"
                                    @mousemove="draw($event)"
                                    @mouseup="stopDrawing()"
                                    @mouseleave="stopDrawing()"
                                    style="touch-action: none;"></canvas>
                        </div>
                    </div>
                    
                    <div class="flex justify-between items-center px-2">
                        <div class="text-[8px] text-slate-500">
                            <span class="font-bold">Tip:</span> Press Ctrl+Z to undo brush strokes
                        </div>
                        <button @click="clearMask()" class="text-[9px] text-slate-400 hover:text-slate-200 uppercase font-bold tracking-widest">
                            <i class="fa-solid fa-eraser mr-1"></i>Clear Mask
                        </button>
                    </div>
                </div>
            </div>

            <!-- Preview Mode: Clickable Images -->
            <template x-if="isPreviewMode">
                <div class="p-4 border-t border-slate-700 bg-slate-800/30">
                    <!-- Preview Image Display - Clickable Selection -->
                    <div class="space-y-3">
                        <div class="text-[10px] text-green-400 font-black uppercase tracking-widest text-center">âœ“ Preview Ready - Click an image to choose</div>
                        <div class="grid grid-cols-2 gap-4">
                            <!-- Original Image - Click to Try Again -->
                            <div class="space-y-1 group">
                                <div class="text-[8px] text-slate-500 font-bold uppercase text-center group-hover:text-orange-400 transition-colors">Original</div>
                                <div class="relative cursor-pointer" @click="discardInpaint()">
                                    <img :src="originalImageBackup" class="rounded-xl border-2 border-slate-700 w-full shadow-lg transition-all duration-200 group-hover:border-orange-500 group-hover:shadow-orange-900/40 group-hover:brightness-90">
                                    <!-- Hover Overlay -->
                                    <div class="absolute inset-0 rounded-xl bg-orange-500/0 group-hover:bg-orange-500/20 transition-all duration-200 flex items-center justify-center">
                                        <div class="opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-orange-600 text-white px-4 py-2 rounded-xl text-[11px] font-black uppercase tracking-widest shadow-lg">
                                            <i class="fa-solid fa-rotate mr-2"></i>Try Again
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Inpainted Image - Click to Accept -->
                            <div class="space-y-1 group">
                                <div class="text-[8px] text-green-400 font-bold uppercase text-center group-hover:text-green-300 transition-colors">Preview</div>
                                <div class="relative cursor-pointer" @click="acceptInpaint()">
                                    <img :src="inpaintPreviewUrl" class="rounded-xl border-2 border-green-500/50 w-full shadow-lg shadow-green-900/20 transition-all duration-200 group-hover:border-green-400 group-hover:shadow-green-500/40 group-hover:brightness-110">
                                    <!-- Hover Overlay -->
                                    <div class="absolute inset-0 rounded-xl bg-green-500/0 group-hover:bg-green-500/20 transition-all duration-200 flex items-center justify-center">
                                        <div class="opacity-0 group-hover:opacity-100 transition-opacity duration-200 bg-green-600 text-white px-4 py-2 rounded-xl text-[11px] font-black uppercase tracking-widest shadow-lg">
                                            <i class="fa-solid fa-check mr-2"></i>Accept
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Cancel button - smaller, secondary -->
                        <div class="flex justify-center pt-2">
                            <button @click="closeInpaintDialog()" class="px-4 py-2 bg-slate-700/50 hover:bg-slate-600 text-slate-400 hover:text-white rounded-xl text-[9px] font-bold uppercase tracking-widest transition-all border border-slate-600/50">
                                <i class="fa-solid fa-xmark mr-1"></i>Cancel
                            </button>
                        </div>
                    </div>
                </div>
            </template>

            <!-- Editing Mode: Show Generate Preview button -->
            <template x-if="!isPreviewMode">
                <div class="p-4 border-t border-slate-700 bg-slate-800/30 flex gap-3">
                    <button @click="generateInpaintPreview()" class="flex-1 bg-orange-600 hover:bg-orange-500 text-white py-3 rounded-2xl text-[11px] font-black uppercase tracking-widest shadow-lg shadow-orange-900/20 transition-all" :disabled="isInpainting">
                        <i class="fa-solid mr-2" :class="isInpainting ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>
                        <span x-show="!isInpainting">Generate Preview</span>
                        <span x-show="isInpainting">Generating...</span>
                    </button>
                    <button @click="closeInpaintDialog()" class="px-6 bg-slate-700 hover:bg-slate-600 text-white rounded-2xl text-[11px] font-black uppercase tracking-widest transition-all">Cancel</button>
                </div>
            </template>
        </div>
    </div>

    <!-- Rename Branch Dialog -->
    <div x-show="showRenameDialog" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-950/80 backdrop-blur-sm" x-cloak x-transition>
        <div class="bg-slate-900 border border-slate-700 w-full max-w-md rounded-3xl shadow-2xl overflow-hidden">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                <h2 class="text-xs font-black uppercase tracking-widest text-blue-400">Rename Branch</h2>
                <button @click="showRenameDialog = false" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="p-6 space-y-4">
                <div class="space-y-2">
                    <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">New Branch Name</label>
                    <input x-model="renameBranchName" class="w-full bg-slate-950 border border-slate-700 rounded-xl px-4 py-2 text-sm outline-none focus:ring-2 focus:ring-blue-500/30" placeholder="Enter new branch name">
                </div>
            </div>

            <div class="p-4 border-t border-slate-700 bg-slate-800/30 flex gap-3">
                <button @click="renameBranch()" class="flex-1 bg-yellow-600 hover:bg-yellow-500 text-white py-3 rounded-2xl text-[11px] font-black uppercase tracking-widest shadow-lg shadow-yellow-900/20 transition-all" :disabled="!renameBranchName || isRenaming">
                    <span x-show="!isRenaming">Rename</span>
                    <span x-show="isRenaming">Renaming...</span>
                </button>
                <button @click="showRenameDialog = false" class="px-6 bg-slate-700 hover:bg-slate-600 text-white rounded-2xl text-[11px] font-black uppercase tracking-widest transition-all">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Character Card Generation Modal -->
    <div x-show="showCardGen" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-950/80 backdrop-blur-sm" x-cloak x-transition>
        <div class="bg-slate-900 border border-slate-700 w-full max-w-5xl rounded-3xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh]">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                <h2 class="text-xs font-black uppercase tracking-widest text-blue-400">Generate Character Card from Chat</h2>
                <button @click="showCardGen = false" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <!-- Source Mode Selector -->
                <div class="flex gap-4 p-4 bg-slate-950/30 rounded-2xl border border-slate-700/50">
                    <button @click="cardGen.source_mode = 'chat'" 
                            class="flex-1 py-2 px-4 rounded-xl text-[10px] font-black uppercase tracking-widest transition-all border"
                            :class="cardGen.source_mode === 'chat' ? 'bg-blue-600 border-blue-500 text-white shadow-lg shadow-blue-900/20' : 'bg-slate-800 border-slate-700 text-slate-500 hover:text-slate-300'">
                        <i class="fa-solid fa-comments mr-2"></i>Current Chat
                    </button>
                    <button @click="cardGen.source_mode = 'manual'" 
                            class="flex-1 py-2 px-4 rounded-xl text-[10px] font-black uppercase tracking-widest transition-all border"
                            :class="cardGen.source_mode === 'manual' ? 'bg-blue-600 border-blue-500 text-white shadow-lg shadow-blue-900/20' : 'bg-slate-800 border-slate-700 text-slate-500 hover:text-slate-300'">
                        <i class="fa-solid fa-file-lines mr-2"></i>Manual Input
                    </button>
                </div>

                <!-- Manual Input Area -->
                <div x-show="cardGen.source_mode === 'manual'" x-transition class="space-y-2">
                    <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">Manual Verbiage / Description</label>
                    <textarea x-model="cardGen.manual_text" 
                              class="w-full bg-slate-950 border border-slate-700 rounded-xl p-4 text-xs h-32 outline-none focus:ring-2 focus:ring-blue-500/30 font-medium leading-relaxed"
                              placeholder="Paste any plain-text description, story snippets, or details about the character here. The LLM will use this as the source for generation."></textarea>
                </div>

                <div class="space-y-2">
                    <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">Target Character Name</label>
                    <div class="flex gap-2">
                        <input x-model="cardGen.char_name" class="flex-1 bg-slate-950 border border-slate-700 rounded-xl px-4 py-2 text-sm outline-none focus:ring-2 focus:ring-blue-500/30" placeholder="e.g. Mark, Sarah, The Barkeeper...">
                        <button @click="generateAllFields()" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-xl text-[10px] font-black uppercase tracking-widest shadow-lg shadow-blue-900/20 transition-all" :disabled="!cardGen.char_name || isGenLoading">
                            <span x-show="!isGenLoading">Auto-Generate All</span>
                            <i x-show="isGenLoading" class="fa-solid fa-circle-notch fa-spin"></i>
                        </button>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Personality -->
                    <div class="space-y-1.5">
                        <div class="flex justify-between items-center">
                            <label class="text-[9px] text-slate-500 uppercase font-black tracking-widest">Personality (PList)</label>
                            <button @click="generateField('personality')" class="text-[8px] text-blue-400 hover:text-blue-300 font-bold uppercase" :disabled="cardGen.loading && cardGen.loading['personality']">
                                <i class="fa-solid mr-1" :class="cardGen.loading && cardGen.loading['personality'] ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Gen
                            </button>
                        </div>
                        <textarea x-model="cardGen.fields.personality" class="w-full bg-slate-950 border border-slate-700 rounded-xl p-3 text-xs h-20 outline-none focus:ring-1 focus:ring-blue-500/50 resize-none font-mono"></textarea>
                    </div>

                    <!-- Body -->
                    <div class="space-y-1.5">
                        <div class="flex justify-between items-center">
                            <label class="text-[9px] text-slate-500 uppercase font-black tracking-widest">Physical Body (PList)</label>
                            <button @click="generateField('body')" class="text-[8px] text-blue-400 hover:text-blue-300 font-bold uppercase" :disabled="cardGen.loading && cardGen.loading['body']">
                                <i class="fa-solid mr-1" :class="cardGen.loading && cardGen.loading['body'] ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Gen
                            </button>
                        </div>
                        <textarea x-model="cardGen.fields.body" class="w-full bg-slate-950 border border-slate-700 rounded-xl p-3 text-xs h-20 outline-none focus:ring-1 focus:ring-blue-500/50 resize-none font-mono"></textarea>
                    </div>

                    <!-- Genre & Tags -->
                    <div class="space-y-1.5">
                        <div class="flex justify-between items-center">
                            <label class="text-[9px] text-slate-500 uppercase font-black tracking-widest">Genre & Tags</label>
                            <button @click="generateField('genre'); generateField('tags')" class="text-[8px] text-blue-400 hover:text-blue-300 font-bold uppercase" :disabled="cardGen.loading && (cardGen.loading['genre'] || cardGen.loading['tags'])">
                                <i class="fa-solid mr-1" :class="cardGen.loading && (cardGen.loading['genre'] || cardGen.loading['tags']) ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Gen
                            </button>
                        </div>
                        <div class="flex gap-2">
                            <input x-model="cardGen.fields.genre" class="w-1/3 bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-xs outline-none focus:ring-1 focus:ring-blue-500/50" placeholder="Genre">
                            <input x-model="cardGen.fields.tags" class="w-2/3 bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-xs outline-none focus:ring-1 focus:ring-blue-500/50" placeholder="Tags (comma separated)">
                        </div>
                    </div>

                    <!-- Scenario -->
                    <div class="space-y-1.5">
                        <div class="flex justify-between items-center">
                            <label class="text-[9px] text-slate-500 uppercase font-black tracking-widest">Scenario</label>
                            <button @click="generateField('scenario')" class="text-[8px] text-blue-400 hover:text-blue-300 font-bold uppercase" :disabled="cardGen.loading && cardGen.loading['scenario']">
                                <i class="fa-solid mr-1" :class="cardGen.loading && cardGen.loading['scenario'] ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Gen
                            </button>
                        </div>
                        <input x-model="cardGen.fields.scenario" class="w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-xs outline-none focus:ring-1 focus:ring-blue-500/50" placeholder="One sentence situation">
                    </div>
                </div>

                <!-- Dialogue Examples -->
                <div class="space-y-1.5">
                    <div class="flex justify-between items-center">
                        <label class="text-[9px] text-slate-500 uppercase font-black tracking-widest">Dialogue Examples (Likes & Story)</label>
                        <button @click="generateField('dialogue_likes'); generateField('dialogue_story')" class="text-[8px] text-blue-400 hover:text-blue-300 font-bold uppercase" :disabled="cardGen.loading && (cardGen.loading['dialogue_likes'] || cardGen.loading['dialogue_story'])">
                            <i class="fa-solid mr-1" :class="cardGen.loading && (cardGen.loading['dialogue_likes'] || cardGen.loading['dialogue_story']) ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Gen
                        </button>
                    </div>
                    <textarea x-model="cardGen.fields.dialogue" class="w-full bg-slate-950 border border-slate-700 rounded-xl p-3 text-xs h-32 outline-none focus:ring-1 focus:ring-blue-500/50 font-medium"></textarea>
                </div>

                <!-- First Message -->
                <div class="space-y-1.5">
                    <div class="flex justify-between items-center">
                        <label class="text-[9px] text-slate-500 uppercase font-black tracking-widest">First Message</label>
                        <button @click="generateField('first_message')" class="text-[8px] text-blue-400 hover:text-blue-300 font-bold uppercase" :disabled="cardGen.loading && cardGen.loading['first_message']">
                            <i class="fa-solid mr-1" :class="cardGen.loading && cardGen.loading['first_message'] ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Gen
                        </button>
                    </div>
                    <textarea x-model="cardGen.fields.first_message" class="w-full bg-slate-950 border border-slate-700 rounded-xl p-3 text-xs h-24 outline-none focus:ring-1 focus:ring-blue-500/50 font-medium"></textarea>
                </div>
            </div>

            <div class="p-4 border-t border-slate-700 bg-slate-800/30 flex gap-3">
                <button @click="saveGeneratedCard()" class="flex-1 bg-green-600 hover:bg-green-500 text-white py-3 rounded-2xl text-[11px] font-black uppercase tracking-widest shadow-lg shadow-green-900/20 transition-all" :disabled="!cardGen.char_name">Save Character Card</button>
                <button @click="showCardGen = false" class="px-6 bg-slate-700 hover:bg-slate-600 text-white rounded-2xl text-[11px] font-black uppercase tracking-widest transition-all">Cancel</button>
            </div>
        </div>
    </div>

    <!-- World Info Generation Modal -->
    <div x-show="showWorldGen" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-950/80 backdrop-blur-sm" x-cloak x-transition>
        <div class="bg-slate-900 border border-slate-700 w-full max-w-6xl rounded-3xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh]">
            <div class="p-4 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                <div class="flex items-center gap-3">
                    <h2 class="text-xs font-black uppercase tracking-widest text-orange-400">World Evolution & Lore Extraction</h2>
                    <div class="flex gap-1 bg-slate-950 p-1 rounded-lg border border-slate-700">
                        <template x-for="t in ['sfw', 'spicy', 'veryspicy']">
                            <button @click="worldGen.tone = t" class="px-2 py-0.5 text-[8px] font-black uppercase rounded transition-all" :class="worldGen.tone === t ? 'bg-orange-600 text-white' : 'text-slate-500 hover:text-slate-300'" x-text="t"></button>
                        </template>
                    </div>
                </div>
                <button @click="showWorldGen = false" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
            </div>
            
            <div class="flex-1 overflow-y-auto p-6 space-y-6">
                <!-- Source Mode Selector -->
                <div class="flex gap-4 p-4 bg-slate-950/30 rounded-2xl border border-slate-700/50">
                    <button @click="worldGen.source_mode = 'chat'" 
                            class="flex-1 py-2 px-4 rounded-xl text-[10px] font-black uppercase tracking-widest transition-all border"
                            :class="worldGen.source_mode === 'chat' ? 'bg-orange-600 border-orange-500 text-white shadow-lg shadow-orange-900/20' : 'bg-slate-800 border-slate-700 text-slate-500 hover:text-slate-300'">
                        <i class="fa-solid fa-comments mr-2"></i>Current Chat
                    </button>
                    <button @click="worldGen.source_mode = 'manual'" 
                            class="flex-1 py-2 px-4 rounded-xl text-[10px] font-black uppercase tracking-widest transition-all border"
                            :class="worldGen.source_mode === 'manual' ? 'bg-orange-600 border-orange-500 text-white shadow-lg shadow-orange-900/20' : 'bg-slate-800 border-slate-700 text-slate-500 hover:text-slate-300'">
                        <i class="fa-solid fa-file-lines mr-2"></i>Manual Input
                    </button>
                </div>

                <!-- Manual Input Area -->
                <div x-show="worldGen.source_mode === 'manual'" x-transition class="space-y-2">
                    <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">Manual Lore / Background Verbiage</label>
                    <textarea x-model="worldGen.manual_text" 
                              class="w-full bg-slate-950 border border-slate-700 rounded-xl p-4 text-xs h-32 outline-none focus:ring-2 focus:ring-orange-500/30 font-medium leading-relaxed"
                              placeholder="Paste plain-text lore, history, or world details here. The LLM will extract PList entries from this text."></textarea>
                </div>

                <div class="space-y-2">
                    <label class="text-[10px] text-slate-500 uppercase font-black tracking-widest">World / Location Name</label>
                    <div class="flex gap-2">
                        <input x-model="worldGen.world_name" class="flex-1 bg-slate-950 border border-slate-700 rounded-xl px-4 py-2 text-sm outline-none focus:ring-2 focus:ring-orange-500/30" placeholder="e.g. Farlandia, Mystic Island...">
                        <button @click="generateAllWorldStuff()" class="bg-orange-600 hover:bg-orange-500 text-white px-4 py-2 rounded-xl text-[10px] font-black uppercase tracking-widest shadow-lg shadow-orange-900/20 transition-all" :disabled="!worldGen.world_name || isWorldLoading">
                            <span x-show="!isWorldLoading">Analyze All Lore</span>
                            <i x-show="isWorldLoading" class="fa-solid fa-circle-notch fa-spin"></i>
                        </button>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <template x-for="section in ['history', 'locations', 'creatures', 'factions']">
                        <div class="space-y-2">
                            <div class="flex justify-between items-center">
                                <label class="text-[9px] text-slate-500 uppercase font-black tracking-widest" x-text="section"></label>
                                <button @click="generateWorldSection(section)" class="text-[8px] text-orange-400 hover:text-orange-300 font-bold uppercase" :disabled="worldGen.loading && worldGen.loading[section]">
                                    <i class="fa-solid mr-1" :class="worldGen.loading && worldGen.loading[section] ? 'fa-circle-notch fa-spin' : 'fa-wand-magic-sparkles'"></i>Extract</button>
                            </div>
                            <textarea x-model="worldGen.fields[section]" class="w-full bg-slate-950 border border-slate-700 rounded-xl p-3 text-[10px] h-32 outline-none focus:ring-1 focus:ring-orange-500/50 font-mono" :placeholder="'[Lore Entry: type(...), details(...)]'"></textarea>
                        </div>
                    </template>
                </div>
            </div>

            <div class="p-4 border-t border-slate-700 bg-slate-800/30 flex gap-3">
                <button @click="saveWorldEvolution()" class="flex-1 bg-green-600 hover:bg-green-500 text-white py-3 rounded-2xl text-[11px] font-black uppercase tracking-widest shadow-lg shadow-green-900/20 transition-all" :disabled="!worldGen.world_name">Finalize & Update World Lore</button>
                <button @click="showWorldGen = false" class="px-6 bg-slate-700 hover:bg-slate-600 text-white rounded-2xl text-[11px] font-black uppercase tracking-widest transition-all">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        function chatUI() {
            return {
                messages: [],
                input: '',
                summary: '',
                isLoading: false,
                isCountingTokens: false,
                tokenCount: 0,
                showSidebar: 'none',
                showImagePanel: false,
                activeCharacters: [],
                characters: [],
                savedChats: [],
                editingChar: null,
                worldInfos: [],
                activeWI: null,
                newWIEntry: { keys: '', content: '' },
                editingMessageId: null,
                editBuffer: '',
                editingWidth: null,
                settings: {
                    system_prompt: 'Write a highly detailed, creative, and immersive response. Stay in character at all times.',
                    user_persona: '',
                    reinforce_freq: 5,
                    world_info_reinforce_freq: 5,
                    temperature: 0.7,
                    max_length: 250,
                    max_context: 4096,
                    summarize_threshold: 0.85,
                    performance_mode_enabled: true
                },
                config: {
                    kobold_url: 'http://127.0.0.1:5001',
                    sd_url: 'http://127.0.0.1:7861'
                },
                sdParams: {
                    prompt: '',
                    negative_prompt: '',
                    steps: 20,
                    cfg_scale: 7.0,
                    width: 512,
                    height: 512,
                    sampler_name: 'Euler a',
                    scheduler: 'Automatic'
                },
                showCardGen: false,
                isGenLoading: false,
                cardGen: {
                    char_name: '',
                    source_mode: 'chat', // 'chat' or 'manual'
                    manual_text: '',
                    loading: {},
                    fields: {
                        personality: '',
                        body: '',
                        dialogue: '',
                        genre: '',
                        tags: '',
                        scenario: '',
                        first_message: ''
                    }
                },
                showWorldGen: false,
                isWorldLoading: false,
                worldGen: {
                    world_name: '',
                    source_mode: 'chat', // 'chat' or 'manual'
                    manual_text: '',
                    tone: 'sfw',
                    fields: {
                        history: '',
                        locations: '',
                        creatures: '',
                        factions: ''
                    }
                },
                isGeneratingCapsule: false,
                
                // Mode selector state
                selectedMode: 'auto', // 'auto', 'narrator', or 'focus:CharacterName'
                isClassifyingMode: false,

                // Inpaint state
                showInpaintDialog: false,
                inpaintImageUrl: '',
                inpaintPrompt: '',
                inpaintMessageIndex: null,
                brushSize: 30,
                isDrawing: false,
                isInpainting: false,
                maskCanvas: null,
                maskCtx: null,
                overlayCtx: null,
                brushHistory: [],
                inpaintPreviewUrl: null,       // Preview result URL
                isPreviewMode: false,          // Whether showing preview
                originalImageBackup: null,     // Backup of original image
                inpaintDenoisingStrength: 0.75, // 0 = keep original, 1 = full inpaint

                async init() {
                    this.loadSettings();
                    await this.fetchCharacters();
                    await this.fetchWorldInfo();
                    await this.fetchChats();
                    
                    // Initialize connection status
                    await this.checkAllServices();
                    
                    // Watch for settings changes to persist
                    this.$watch('settings', () => this.saveSettings());
                    this.$watch('sdParams', () => this.saveSettings());
                    
                    // Periodic token count update
                    setInterval(() => {
                        if (this.messages.length > 0 && !this.isLoading) this.updateTokenCount();
                    }, 30000);
                    
                    // Initialize adaptive connection monitoring
                    this.initConnectionMonitoring();
                    
                    // Page visibility API for background optimization
                    document.addEventListener('visibilitychange', () => {
                        if (document.hidden) {
                            this.pauseConnectionMonitoring();
                        } else {
                            this.resumeConnectionMonitoring();
                        }
                    });
                },

                // Adaptive connection monitoring system
                connectionMonitoring: {
                    interval: null,
                    baseInterval: 30000, // 30 seconds base interval
                    currentInterval: 30000,
                    consecutiveFailures: 0,
                    lastSuccessTime: 0,
                    isMonitoring: false,
                    isPaused: false
                },

                initConnectionMonitoring() {
                    this.connectionMonitoring.isMonitoring = true;
                    this.connectionMonitoring.lastSuccessTime = Date.now();
                    this.startConnectionMonitoring();
                },

                startConnectionMonitoring() {
                    if (this.connectionMonitoring.interval) return;
                    
                    this.connectionMonitoring.interval = setInterval(() => {
                        if (!this.connectionMonitoring.isPaused && this.connectionMonitoring.isMonitoring) {
                            this.adaptiveCheckAllServices();
                        }
                    }, this.connectionMonitoring.currentInterval);
                },

                pauseConnectionMonitoring() {
                    this.connectionMonitoring.isPaused = true;
                    if (this.connectionMonitoring.interval) {
                        clearInterval(this.connectionMonitoring.interval);
                        this.connectionMonitoring.interval = null;
                    }
                },

                resumeConnectionMonitoring() {
                    this.connectionMonitoring.isPaused = false;
                    this.startConnectionMonitoring();
                    // Check immediately when resuming
                    this.checkAllServices();
                },

                adaptiveCheckAllServices() {
                    this.checkAllServices().then(() => {
                        this.handleConnectionSuccess();
                    }).catch(() => {
                        this.handleConnectionFailure();
                    });
                },

                handleConnectionSuccess() {
                    const now = Date.now();
                    const timeSinceLastSuccess = now - this.connectionMonitoring.lastSuccessTime;
                    
                    // Reset failure count
                    this.connectionMonitoring.consecutiveFailures = 0;
                    this.connectionMonitoring.lastSuccessTime = now;
                    
                    // Adaptive interval adjustment for stable connections
                    if (timeSinceLastSuccess > 300000) { // 5 minutes of stability
                        // Increase interval up to 60 seconds for very stable connections
                        this.connectionMonitoring.currentInterval = Math.min(60000, this.connectionMonitoring.currentInterval + 5000);
                    } else if (this.connectionMonitoring.currentInterval > this.connectionMonitoring.baseInterval) {
                        // Gradually return to base interval
                        this.connectionMonitoring.currentInterval = Math.max(
                            this.connectionMonitoring.baseInterval, 
                            this.connectionMonitoring.currentInterval - 1000
                        );
                    }
                    
                    // Update interval if changed
                    if (this.connectionMonitoring.interval) {
                        clearInterval(this.connectionMonitoring.interval);
                        this.connectionMonitoring.interval = setInterval(() => {
                            if (!this.connectionMonitoring.isPaused && this.connectionMonitoring.isMonitoring) {
                                this.adaptiveCheckAllServices();
                            }
                        }, this.connectionMonitoring.currentInterval);
                    }
                },

                handleConnectionFailure() {
                    this.connectionMonitoring.consecutiveFailures++;
                    
                    // Aggressive monitoring during disconnection
                    if (this.connectionMonitoring.consecutiveFailures <= 3) {
                        // Short interval for initial failures (10 seconds)
                        this.connectionMonitoring.currentInterval = 10000;
                    } else {
                        // Even shorter interval for persistent failures (5 seconds)
                        this.connectionMonitoring.currentInterval = 5000;
                    }
                    
                    // Update interval immediately
                    if (this.connectionMonitoring.interval) {
                        clearInterval(this.connectionMonitoring.interval);
                        this.connectionMonitoring.interval = setInterval(() => {
                            if (!this.connectionMonitoring.isPaused && this.connectionMonitoring.isMonitoring) {
                                this.adaptiveCheckAllServices();
                            }
                        }, this.connectionMonitoring.currentInterval);
                    }
                },

                loadSettings() {
                    const saved = localStorage.getItem('ai_chat_settings');
                    if (saved) {
                        try {
                            const parsed = JSON.parse(saved);
                            if (parsed.settings) this.settings = { ...this.settings, ...parsed.settings };
                            if (parsed.sdParams) this.sdParams = { ...this.sdParams, ...parsed.sdParams };
                            // Backward compatibility for old format where settings was the root
                            if (!parsed.settings && !parsed.sdParams) this.settings = { ...this.settings, ...parsed };
                        } catch (e) { console.error('Failed to load settings', e); }
                    }
                },

                saveSettings() {
                    const toSave = {
                        settings: this.settings,
                        sdParams: this.sdParams
                    };
                    localStorage.setItem('ai_chat_settings', JSON.stringify(toSave));
                },

                async updateTokenCount() {
                    if (this.isCountingTokens) return;
                    this.isCountingTokens = true;
                    try {
                        const prompt = this.constructPromptLocally();
                        const res = await axios.post('/api/extra/tokencount', { prompt });
                        this.tokenCount = res.data.count;
                    } catch (e) {
                        console.error('Token count failed', e);
                    } finally {
                        this.isCountingTokens = false;
                    }
                },

                constructPromptLocally() {
                    // Optimized to match main.py logic accurately
                    let p = `### System: ${this.settings.system_prompt}\n`;
                    
                    // Multi-character mode instructions (simulated)
                    const isGroupChat = this.activeCharacters.length >= 2;
                    if (isGroupChat) p += "\n[MODE: NARRATOR]\n(Narrator Instructions here)\n";
                    
                    if (this.summary) p += `### Long-Term Context (Summary of earlier turns):\n${this.summary}\n`;
                    if (this.settings.user_persona) p += `### Your Character Description:\n${this.settings.user_persona}\n`;
                    
                    let reinforcementChunks = [];
                    this.activeCharacters.forEach(c => {
                        const name = c.data.name;
                        const multi_char_summary = c.data.extensions?.multi_char_summary;
                        
                        if (isGroupChat && multi_char_summary) {
                            p += `### [${name}]: ${multi_char_summary}\n`;
                            reinforcementChunks.push(`[${name}]: ${multi_char_summary}`);
                        } else {
                            p += `### Character Profile: ${name}\n${c.data.description}\n`;
                            if (c.data?.extensions?.depth_prompt?.prompt) {
                                p += `### Context for ${name}: ${c.data.extensions.depth_prompt.prompt}\n`;
                                reinforcementChunks.push(c.data.extensions.depth_prompt.prompt);
                            }
                        }
                    });

                    let canon_entries = [];
                    if (this.settings.world_info_enabled && this.activeWI) {
                        // Estimate triggered lore overhead (approx 150 tokens)
                        p += "### World Knowledge:\n[Triggered Lore Placeholder]\n";
                        
                        // Extract canon law for reinforcement simulation
                        canon_entries = Object.values(this.activeWI.entries || {})
                            .filter(e => e.is_canon_law)
                            .map(e => e.content);
                    }

                    p += "\n### Chat History:\n";
                    const worldFreq = this.settings.world_info_reinforce_freq || 5;
                    const charFreq = this.settings.reinforce_freq || 0;
                    let lastWorldReinforce = -1;

                    this.messages.forEach((m, i) => {
                        if (m.speaker === 'Visual System') return;

                        // Simulate character reinforcement
                        if (charFreq > 0 && i > 0 && i % charFreq === 0) {
                            if (reinforcementChunks.length > 0) {
                                p += "[REINFORCEMENT: " + reinforcementChunks.join(" | ") + "]\n";
                            }
                        }
                        
                        // Simulate world reinforcement
                        if (worldFreq > 0 && i > 0 && i % worldFreq === 0) {
                            if (canon_entries.length > 0) {
                                p += "[WORLD REINFORCEMENT: " + canon_entries.join(" | ") + "]\n";
                                lastWorldReinforce = i;
                            }
                        }

                        const speaker = m.speaker || (m.role === 'user' ? 'User' : 'Narrator');
                        p += `${speaker}: ${m.content}\n`;
                    });
                    
                    // Final Canon Law Pin (Recency Bias) - with redundancy check matching backend
                    const turnsSinceReinforce = this.messages.length - 1 - lastWorldReinforce;
                    if (canon_entries.length > 0) {
                        if (worldFreq === 1 || turnsSinceReinforce > 3) {
                            p += "\n### Canon Law (World Rules):\n" + canon_entries.join("\n") + "\n";
                        }
                    }

                    p += "Narrator:";
                    return p;
                },

                async fetchChats() {
                    try {
                        const res = await axios.get('/api/chats');
                        this.savedChats = res.data;
                    } catch (e) { console.error(e); }
                },

                async saveNewChat() {
                    const name = prompt("Name this chat session:");
                    if (!name) return;
                    
                    const data = {
                        messages: this.messages,
                        summary: this.summary,
                        activeCharacters: this.activeCharacters,
                        activeWI: this.activeWI,
                        settings: this.settings
                    };
                    
                    try {
                        await axios.post('/api/chats', { name, data });
                        await this.fetchChats();
                    } catch (e) { console.error(e); }
                },

                async loadChat(name) {
                    if (this.messages.length > 0 && !confirm('Load chat? Current progress will be lost.')) return;
                    try {
                        const res = await axios.get(`/api/chats/${name}`);
                        const d = res.data;
                        this.messages = d.messages || [];
                        this.summary = d.summary || '';
                        this.activeCharacters = d.activeCharacters || [];
                        this.activeWI = d.activeWI || null;
                        this.settings = { ...this.settings, ...(d.settings || {}) };
                        this.currentChatName = name;
                        // Ensure dialogs are closed when loading a chat
                        this.showForkDialog = false;
                        this.showBranchDialog = false;
                        this.showRenameDialog = false;
                        this.showSidebar = 'none';
                        this.scrollToBottom();
                        this.updateTokenCount();
                    } catch (e) { console.error(e); }
                },

                async deleteChat(name) {
                    if (confirm(`Delete chat "${name}"?`)) {
                        try {
                            await axios.delete(`/api/chats/${name}`);
                            await this.fetchChats();
                        } catch (e) { console.error(e); }
                    }
                },

                startNewCharacter() {
                    this.editingChar = {
                        data: {
                            name: 'New',
                            description: '',
                            extensions: {
                                depth_prompt: { depth: 4, prompt: '' }
                            }
                        }
                    };
                },

                startEditCharacter(char) {
                    const clone = JSON.parse(JSON.stringify(char));
                    if (!clone.data.extensions) clone.data.extensions = {};
                    if (!clone.data.extensions.depth_prompt) {
                        clone.data.extensions.depth_prompt = { depth: 4, prompt: '' };
                    }
                    this.editingChar = clone;
                },

                isCharacterActive(char) {
                    return this.activeCharacters.some(c => c.data?.name === char.data?.name);
                },

                toggleCharacter(char) {
                    const index = this.activeCharacters.findIndex(c => c.data?.name === char.data?.name);
                    if (index > -1) {
                        this.activeCharacters.splice(index, 1);
                    } else {
                        this.activeCharacters.push(char);
                        if (char.data?.first_mes && this.messages.length === 0) {
                            this.messages.push({
                                role: 'assistant',
                                speaker: char.data.name,
                                content: char.data.first_mes,
                                id: Date.now()
                            });
                        }
                    }
                },

                async deleteMessage(index) {
                    if (confirm('Delete this turn from history?')) {
                        this.messages.splice(index, 1);
                        this.updateTokenCount();
                    }
                },

                updateMessage(index) {
                    this.messages[index].content = this.editBuffer;
                    this.editingMessageId = null;
                    this.editBuffer = '';
                    this.updateTokenCount();
                },

                async regenerate(index) {
                    if (this.isLoading) return;
                    this.messages = this.messages.slice(0, index + 1);
                    this.isLoading = true;
                    this.scrollToBottom();

                    try {
                        // Get the user message content for mode resolution
                        const lastUserMsg = this.messages[index];
                        const mode = await this.resolveMode(lastUserMsg?.content || '');
                        
                        const res = await axios.post('/api/chat', { 
                            messages: this.messages,
                            summary: this.summary,
                            characters: this.activeCharacters,
                            world_info: this.settings.world_info_enabled ? this.activeWI : null,
                            settings: this.settings,
                            mode: mode
                        });

                        // Only replace messages if summarization/truncation occurred (summary changed)
                        if (res.data._updated_state) {
                            if (res.data._updated_state.summary !== this.summary) {
                                // Summarization happened - use backend's truncated message list
                                this.messages = res.data._updated_state.messages;
                            }
                            this.summary = res.data._updated_state.summary;
                        }

                        // Check if response has the expected structure
                        if (!res.data) {
                            throw new Error('Invalid response structure from server');
                        }

                        // Handle different response formats
                        let aiContent = '';
                        
                        // Check for the new format: message.content
                        if (res.data.message && res.data.message.content) {
                            aiContent = res.data.message.content;
                        }
                        // Check for the old format: results[0].text
                        else if (res.data.results && Array.isArray(res.data.results) && res.data.results.length > 0 && res.data.results[0].text) {
                            aiContent = res.data.results[0].text;
                        }
                        // Check for direct text field
                        else if (res.data.text) {
                            aiContent = res.data.text;
                        }
                        else {
                            throw new Error('No valid content found in response');
                        }

                        const aiMsg = { 
                            role: 'assistant', 
                            speaker: this.getSpeakerFromMode(mode),
                            content: aiContent.trim(), 
                            id: Date.now() + 1 
                        };
                        this.messages.push(aiMsg);
                    } catch (e) {
                        console.error('Regenerate failed:', e);
                        // Show user-friendly error message
                        const errorMsg = e.response?.data?.error || e.message || 'Failed to regenerate message';
                        this.messages.push({
                            role: 'assistant',
                            speaker: 'System',
                            content: `Error: ${errorMsg}`,
                            id: Date.now() + 1
                        });
                    } finally {
                        this.isLoading = false;
                        this.scrollToBottom();
                        this.updateTokenCount();
                    }
                },

                async fetchCharacters() {
                    try {
                        const res = await axios.get('/api/characters');
                        this.characters = res.data;
                    } catch (e) { console.error(e); }
                },

                async saveCharacter() {
                    try {
                        await axios.post('/api/characters', this.editingChar);
                        this.editingChar = null;
                        await this.fetchCharacters();
                    } catch (e) { console.error(e); }
                },

                async deleteCharacter(char) {
                    if (confirm(`Delete character card: ${char.data.name}?`)) {
                        try {
                            const filename = char._filename || `${char.data.name}.json`;
                            await axios.delete(`/api/characters/${filename}`);
                            await this.fetchCharacters();
                        } catch (e) { console.error(e); }
                    }
                },

                async fetchWorldInfo() {
                    try {
                        const res = await axios.get('/api/world-info');
                        this.worldInfos = res.data;
                        // If we have an active world info, update it from the list to get latest flags
                        if (this.activeWI) {
                            const updated = this.worldInfos.find(w => w.name === this.activeWI.name);
                            if (updated) this.activeWI = updated;
                        }
                    } catch (e) { console.error(e); }
                },

                toggleCanonLaw(wi, uid) {
                    const entry = wi.entries[uid];
                    entry.is_canon_law = !entry.is_canon_law;
                    this.saveWorldInfo(wi.name, wi.entries);
                },

                async saveWorldInfo(name, data) {
                    try {
                        await axios.post('/api/world-info', { name, data });
                        await this.fetchWorldInfo();
                    } catch (e) { console.error(e); }
                },

                // Resolve the mode to use - handles "auto" by calling the classifier API
                async resolveMode(userMessage) {
                    // If KoboldCpp is disconnected, always use narrator mode
                    if (!this.canGenerateText()) {
                        console.warn('KoboldCpp disconnected, forcing narrator mode');
                        return 'narrator';
                    }
                    
                    // Initialize activeCharacters if undefined
                    if (!this.activeCharacters) {
                        this.activeCharacters = [];
                    }
                    
                    // For single character, default to that character's focus mode (unless user chose narrator)
                    if (this.activeCharacters.length === 1) {
                        if (this.selectedMode === 'narrator') return 'narrator';
                        if (this.selectedMode === 'auto') return 'focus:' + this.activeCharacters[0].data.name;
                        return this.selectedMode;
                    }
                    
                    // For 0 characters, always narrator
                    if (this.activeCharacters.length === 0) {
                        return 'narrator';
                    }
                    
                    // For multiple characters with non-auto selection, use that
                    if (this.selectedMode !== 'auto') {
                        return this.selectedMode;
                    }
                    
                    // Auto mode with multiple characters - call the classifier
                    this.isClassifyingMode = true;
                    try {
                        const charNames = this.activeCharacters.map(c => c.data.name);
                        const res = await axios.post('/api/classify-mode', {
                            user_message: userMessage,
                            character_names: charNames
                        });
                        
                        if (res.data.success) {
                            console.log(`Auto-classified mode: ${res.data.mode}`);
                            return res.data.mode;
                        }
                    } catch (e) {
                        console.error('Mode classification failed, defaulting to narrator', e);
                    } finally {
                        this.isClassifyingMode = false;
                    }
                    
                    // Fallback to narrator mode
                    return 'narrator';
                },

                // Determine speaker label for AI response based on mode
                getSpeakerFromMode(resolvedMode) {
                    if (resolvedMode.startsWith('focus:')) {
                        return resolvedMode.split(':')[1];
                    }
                    return 'Narrator';
                },

                async sendMessage() {
                    if (!this.input.trim() || this.isLoading) return;
                    
                    const userMsg = { role: 'user', content: this.input, id: Date.now() };
                    this.messages.push(userMsg);
                    const currentInput = this.input;
                    this.input = '';
                    this.isLoading = true;
                    this.scrollToBottom();

                    try {
                        // Resolve the mode (may call auto-classifier)
                        const mode = await this.resolveMode(currentInput);
                        
                        const res = await axios.post('/api/chat', { 
                            messages: this.messages,
                            summary: this.summary,
                            characters: this.activeCharacters,
                            world_info: this.settings.world_info_enabled ? this.activeWI : null,
                            settings: this.settings,
                            mode: mode
                        });

                        // Only replace messages if summarization/truncation occurred (summary changed)
                        if (res.data._updated_state) {
                            if (res.data._updated_state.summary !== this.summary) {
                                // Summarization happened - use backend's truncated message list
                                this.messages = res.data._updated_state.messages;
                            }
                            this.summary = res.data._updated_state.summary;
                        }

                        // Check if response has the expected structure
                        if (!res.data) {
                            throw new Error('Invalid response structure from server');
                        }

                        // Handle different response formats
                        let aiContent = '';
                        
                        // Check for the new format: message.content
                        if (res.data.message && res.data.message.content) {
                            aiContent = res.data.message.content;
                        }
                        // Check for the old format: results[0].text
                        else if (res.data.results && Array.isArray(res.data.results) && res.data.results.length > 0 && res.data.results[0].text) {
                            aiContent = res.data.results[0].text;
                        }
                        // Check for direct text field
                        else if (res.data.text) {
                            aiContent = res.data.text;
                        }
                        else {
                            throw new Error('No valid content found in response');
                        }

                        const aiMsg = { 
                            role: 'assistant', 
                            speaker: this.getSpeakerFromMode(mode),
                            content: aiContent.trim(), 
                            id: Date.now() + 1 
                        };
                        this.messages.push(aiMsg);
                    } catch (e) {
                        console.error('Send message failed:', e);
                        // Show user-friendly error message
                        const errorMsg = e.response?.data?.error || e.message || 'Failed to send message';
                        this.messages.push({
                            role: 'assistant',
                            speaker: 'System',
                            content: `Error: ${errorMsg}`,
                            id: Date.now() + 1
                        });
                    } finally {
                        this.isLoading = false;
                        this.scrollToBottom();
                        this.updateTokenCount();
                    }
                },

                async generateImage() {
                    this.isLoading = true;
                    this.showImagePanel = false;
                    try {
                        const res = await axios.post('/api/generate-image', this.sdParams);
                        // Push a new message for the image instead of attaching it to the last one
                        const imageMsg = {
                            role: 'assistant',
                            speaker: 'Visual System',
                            content: '',
                            image: res.data.url,
                            id: Date.now()
                        };
                        this.messages.push(imageMsg);
                    } catch (e) {
                        console.error(e);
                    } finally {
                        this.isLoading = false;
                        this.scrollToBottom();
                    }
                },

                openCardGen() {
                    this.showCardGen = true;
                },

                openWorldGen() {
                    this.showWorldGen = true;
                },

                async generateField(fieldType) {
                    // Force Reactivity
                    if (!this.cardGen.loading) this.cardGen.loading = {};
                    
                    if (!this.cardGen.char_name) {
                        alert("Please enter a character name first.");
                        return;
                    }
                    
                    if (this.cardGen.source_mode === 'manual' && !this.cardGen.manual_text.trim()) {
                        alert("Please enter some manual text to analyze.");
                        return;
                    }

                    if (this.cardGen.source_mode === 'chat' && this.messages.length === 0) {
                        alert("Start a conversation first to extract details, or switch to Manual mode!");
                        return;
                    }
                    
                    this.cardGen.loading[fieldType] = true;
                    
                    let contextText = "";
                    if (this.cardGen.source_mode === 'manual') {
                        contextText = this.cardGen.manual_text;
                    } else {
                        // Simple context extraction: last 20 messages
                        contextText = this.messages.slice(-20).map(m => `${m.speaker || (m.role === 'user' ? 'User' : 'Narrator')}: ${m.content}`).join('\n');
                    }
                    
                    try {
                        const res = await axios.post('/api/card-gen/generate-field', {
                            char_name: this.cardGen.char_name,
                            field_type: fieldType,
                            context: contextText,
                            source_mode: this.cardGen.source_mode
                        });
                        
                        if (res.data.success) {
                            if (fieldType.startsWith('dialogue')) {
                                if (!this.cardGen.fields.dialogue.includes('<START>')) this.cardGen.fields.dialogue = '';
                                this.cardGen.fields.dialogue += (this.cardGen.fields.dialogue ? '\n' : '') + '<START>\n' + res.data.text;
                            } else {
                                this.cardGen.fields[fieldType] = res.data.text;
                            }
                        } else {
                            alert(`Error generating ${fieldType}: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error(`Failed to gen ${fieldType}`, e);
                        alert(`Connection error generating ${fieldType}. Is the backend running?`);
                    } finally {
                        this.cardGen.loading[fieldType] = false;
                    }
                },

                async generateAllFields() {
                    const fields = ['personality', 'body', 'genre', 'tags', 'scenario', 'first_message', 'dialogue_likes', 'dialogue_story'];
                    
                    if (this.cardGen.source_mode === 'manual' && !this.cardGen.manual_text.trim()) {
                        alert("Please enter some manual text to analyze.");
                        return;
                    }
                    if (this.cardGen.source_mode === 'chat' && this.messages.length === 0) {
                        alert("Start a conversation first to extract details, or switch to Manual mode!");
                        return;
                    }

                    this.isGenLoading = true;
                    this.cardGen.fields.dialogue = ''; // Clear dialogue before fresh gen
                    
                    for (const f of fields) {
                        await this.generateField(f);
                    }
                    this.isGenLoading = false;
                },

                async saveGeneratedCard() {
                    // Create SillyTavern V2 format
                    const character_note_parts = [];
                    if (this.cardGen.fields.personality) character_note_parts.push(this.cardGen.fields.personality);
                    if (this.cardGen.fields.body) character_note_parts.push(this.cardGen.fields.body);
                    
                    const metadata = [];
                    if (this.cardGen.fields.genre) metadata.push(`Genre: ${this.cardGen.fields.genre}`);
                    if (this.cardGen.fields.tags) metadata.push(`Tags: ${this.cardGen.fields.tags}`);
                    if (this.cardGen.fields.scenario) metadata.push(`Scenario: ${this.cardGen.fields.scenario}`);
                    
                    if (metadata.length > 0) character_note_parts.push(`[${metadata.join('; ')}]`);
                    const character_note = character_note_parts.join('\n');

                    const newCard = {
                        spec: "chara_card_v2",
                        spec_version: "2.0",
                        data: {
                            name: this.cardGen.char_name,
                            description: this.cardGen.fields.dialogue,
                            personality: "",
                            scenario: "",
                            first_mes: this.cardGen.fields.first_message,
                            mes_example: "",
                            creator_notes: character_note,
                            system_prompt: "",
                            post_history_instructions: "",
                            alternate_greetings: [],
                            character_book: null,
                            tags: this.cardGen.fields.tags ? this.cardGen.fields.tags.split(',').map(t => t.trim()) : [],
                            creator: "",
                            character_version: "",
                            extensions: {
                                depth_prompt: {
                                    prompt: character_note,
                                    depth: 4
                                },
                                danbooru_tag: '',
                                label_description: ''
                            }
                        }
                    };

                    try {
                        const res = await axios.post('/api/characters', newCard);
                        if (res.data.success) {
                            alert(`Character "${this.cardGen.char_name}" saved!`);
                            this.showCardGen = false;
                            await this.fetchCharacters();
                        }
                    } catch (e) {
                        console.error("Save failed", e);
                        alert("Failed to save character card.");
                    }
                },

                async generateWorldSection(section) {
                    if (!this.worldGen.loading) this.worldGen.loading = {};
                    if (!this.worldGen.world_name) return;
                    
                    if (this.worldGen.source_mode === 'manual' && !this.worldGen.manual_text.trim()) {
                        alert("Please enter some manual text to analyze.");
                        return;
                    }

                    if (this.worldGen.source_mode === 'chat' && this.messages.length === 0) {
                        alert("Start a conversation first to extract details, or switch to Manual mode!");
                        return;
                    }

                    let contextText = "";
                    if (this.worldGen.source_mode === 'manual') {
                        contextText = this.worldGen.manual_text;
                    } else {
                        // World info needs more context, take up to 50 messages
                        contextText = this.messages.slice(-50).map(m => `${m.speaker || (m.role === 'user' ? 'User' : 'Narrator')}: ${m.content}`).join('\n');
                    }
                    
                    this.worldGen.loading[section] = true;
                    try {
                        const res = await axios.post('/api/world-gen/generate', {
                            world_name: this.worldGen.world_name,
                            section: section,
                            tone: this.worldGen.tone,
                            context: contextText,
                            source_mode: this.worldGen.source_mode
                        });
                        
                        if (res.data.success) {
                            this.worldGen.fields[section] = res.data.text;
                        }
                    } catch (e) {
                        console.error(`Failed to gen world lore: ${section}`, e);
                    } finally {
                        this.worldGen.loading[section] = false;
                    }
                },

                async generateAllWorldStuff() {
                    this.isWorldLoading = true;
                    const sections = ['history', 'locations', 'creatures', 'factions'];
                    for (const s of sections) {
                        await this.generateWorldSection(s);
                    }
                    this.isWorldLoading = false;
                },

                async saveWorldEvolution() {
                    const allEntries = [
                        this.worldGen.fields.history,
                        this.worldGen.fields.locations,
                        this.worldGen.fields.creatures,
                        this.worldGen.fields.factions
                    ].filter(t => t.trim()).join('\n');

                    if (!allEntries) {
                        alert("No lore entries generated to save!");
                        return;
                    }

                    try {
                        const res = await axios.post('/api/world-gen/save', {
                            world_name: this.worldGen.world_name,
                            plist_text: allEntries
                        });
                        
                        if (res.data.success) {
                            alert(`World Lore "${this.worldGen.world_name}" updated successfully!`);
                            this.showWorldGen = false;
                            await this.fetchWorldInfo();
                        }
                    } catch (e) {
                        console.error("World save failed", e);
                        alert("Failed to save world lore.");
                    }
                },

                async generateCapsule() {
                    if (!this.editingChar || !this.editingChar.data.name) {
                        alert("Please enter a character name first.");
                        return;
                    }
                    
                    this.isGeneratingCapsule = true;
                    
                    try {
                        const res = await axios.post('/api/card-gen/generate-capsule', {
                            char_name: this.editingChar.data.name,
                            description: this.editingChar.data.description || '',
                            depth_prompt: this.editingChar.data.extensions?.depth_prompt?.prompt || ''
                        });
                        
                        if (res.data.success) {
                            // Ensure extensions object exists
                            if (!this.editingChar.data.extensions) {
                                this.editingChar.data.extensions = {};
                            }
                            this.editingChar.data.extensions.multi_char_summary = res.data.text;
                        } else {
                            alert(`Error generating capsule: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error("Capsule generation failed", e);
                        alert("Failed to generate capsule. Is the backend running?");
                    } finally {
                        this.isGeneratingCapsule = false;
                    }
                },

                // Character Editing Functions
                editContextMode: 'chat', // 'chat' or 'manual'
                editContextText: '',
                isEditingField: false,
                isEditingCapsule: false,

                async editFieldAI(field) {
                    if (!this.editingChar || !this.editingChar.data.name) {
                        alert("Please save the character first.");
                        return;
                    }
                    
                    this.isEditingField = true;
                    
                    let contextText = "";
                    if (this.editContextMode === 'manual') {
                        if (!this.editContextText.trim()) {
                            alert("Please provide context for AI generation.");
                            this.isEditingField = false;
                            return;
                        }
                        contextText = this.editContextText;
                    } else {
                        // Use current chat context
                        if (this.messages.length === 0) {
                            alert("Start a conversation first to extract details.");
                            this.isEditingField = false;
                            return;
                        }
                        // Use last 20 messages for context
                        contextText = this.messages.slice(-20).map(m => `${m.speaker || (m.role === 'user' ? 'User' : 'Narrator')}: ${m.content}`).join('\n');
                    }
                    
                    try {
                        const res = await axios.post('/api/characters/edit-field-ai', {
                            filename: this.editingChar._filename || `${this.editingChar.data.name}.json`,
                            field: field,
                            context: contextText,
                            source_mode: this.editContextMode
                        });
                        
                        if (res.data.success) {
                            // Update the character data
                            this.editingChar.data[field] = res.data.text;
                            alert(`${field} updated successfully!`);
                        } else {
                            alert(`Error updating ${field}: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error(`Failed to edit ${field}`, e);
                        alert(`Connection error updating ${field}. Is the backend running?`);
                    } finally {
                        this.isEditingField = false;
                    }
                },

                async editCapsuleAI() {
                    if (!this.editingChar || !this.editingChar.data.name) {
                        alert("Please save the character first.");
                        return;
                    }
                    
                    this.isEditingCapsule = true;
                    
                    let contextText = "";
                    if (this.editContextMode === 'manual') {
                        if (!this.editContextText.trim()) {
                            alert("Please provide context for AI generation.");
                            this.isEditingCapsule = false;
                            return;
                        }
                        contextText = this.editContextText;
                    } else {
                        // Use current chat context
                        if (this.messages.length === 0) {
                            alert("Start a conversation first to extract details.");
                            this.isEditingCapsule = false;
                            return;
                        }
                        // Use last 20 messages for context
                        contextText = this.messages.slice(-20).map(m => `${m.speaker || (m.role === 'user' ? 'User' : 'Narrator')}: ${m.content}`).join('\n');
                    }
                    
                    try {
                        const res = await axios.post('/api/characters/edit-capsule-ai', {
                            filename: this.editingChar._filename || `${this.editingChar.data.name}.json`,
                            context: contextText,
                            source_mode: this.editContextMode
                        });
                        
                        if (res.data.success) {
                            // Ensure extensions object exists
                            if (!this.editingChar.data.extensions) {
                                this.editingChar.data.extensions = {};
                            }
                            this.editingChar.data.extensions.multi_char_summary = res.data.text;
                            alert("Capsule updated successfully!");
                        } else {
                            alert(`Error updating capsule: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error("Capsule AI update failed", e);
                        alert("Failed to update capsule. Is the backend running?");
                    } finally {
                        this.isEditingCapsule = false;
                    }
                },

                async saveCharacter() {
                    try {
                        await axios.post('/api/characters', this.editingChar);
                        this.editingChar = null;
                        await this.fetchCharacters();
                        alert("Character saved successfully!");
                    } catch (e) {
                        console.error(e);
                        alert("Failed to save character. Is the backend running?");
                    }
                },

                // World Info Editing Functions
                editingWorldEntry: null,
                worldEditContextMode: 'chat', // 'chat' or 'manual'
                worldEditContextText: '',
                isEditingWorldEntry: false,
                isAddingWorldEntry: false,
                isDeletingWorldEntry: false,

                startEditWorldEntry(worldInfo, entryUid) {
                    const entry = worldInfo.entries[entryUid];
                    this.editingWorldEntry = {
                        world_name: worldInfo.name,
                        entry_uid: entryUid,
                        entry: {
                            key: Array.isArray(entry.key) ? entry.key.join(', ') : entry.key || '',
                            comment: entry.comment || '',
                            content: entry.content || '',
                            is_canon_law: entry.is_canon_law || false,
                            useProbability: entry.useProbability || false,
                            probability: entry.probability || 100
                        }
                    };
                },

                async saveWorldEntry() {
                    if (!this.editingWorldEntry) return;
                    
                    try {
                        const res = await axios.post('/api/world-info/edit-entry', {
                            world_name: this.editingWorldEntry.world_name,
                            entry_uid: this.editingWorldEntry.entry_uid,
                            field: 'content',
                            new_value: this.editingWorldEntry.entry.content
                        });
                        
                        if (res.data.success) {
                            // Update the world info in memory
                            const worldIndex = this.worldInfos.findIndex(w => w.name === this.editingWorldEntry.world_name);
                            if (worldIndex !== -1) {
                                this.worldInfos[worldIndex].entries[this.editingWorldEntry.entry_uid] = {
                                    ...this.worldInfos[worldIndex].entries[this.editingWorldEntry.entry_uid],
                                    content: this.editingWorldEntry.entry.content,
                                    key: this.editingWorldEntry.entry.key.split(',').map(k => k.trim()),
                                    comment: this.editingWorldEntry.entry.comment,
                                    is_canon_law: this.editingWorldEntry.entry.is_canon_law,
                                    useProbability: this.editingWorldEntry.entry.useProbability,
                                    probability: this.editingWorldEntry.entry.probability
                                };
                            }
                            alert("World info entry saved successfully!");
                            this.editingWorldEntry = null;
                        } else {
                            alert(`Error saving entry: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error("Failed to save world entry", e);
                        alert("Failed to save world info entry. Is the backend running?");
                    }
                },

                async addWorldEntry() {
                    if (!this.editingWorldEntry || !this.editingWorldEntry.world_name) return;
                    
                    this.isAddingWorldEntry = true;
                    
                    try {
                        const res = await axios.post('/api/world-info/add-entry', {
                            world_name: this.editingWorldEntry.world_name,
                            entry_data: {
                                key: this.editingWorldEntry.entry.key.split(',').map(k => k.trim()),
                                comment: this.editingWorldEntry.entry.comment,
                                content: this.editingWorldEntry.entry.content,
                                is_canon_law: this.editingWorldEntry.entry.is_canon_law,
                                useProbability: this.editingWorldEntry.entry.useProbability,
                                probability: this.editingWorldEntry.entry.probability
                            }
                        });
                        
                        if (res.data.success) {
                            // Refresh the world info
                            await this.fetchWorldInfo();
                            alert("New world info entry added successfully!");
                            this.editingWorldEntry = null;
                        } else {
                            alert(`Error adding entry: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error("Failed to add world entry", e);
                        alert("Failed to add world info entry. Is the backend running?");
                    } finally {
                        this.isAddingWorldEntry = false;
                    }
                },

                async deleteWorldEntry(worldName, entryUid) {
                    if (!worldName || !entryUid) return;
                    
                    if (!confirm('Delete this world info entry?')) return;
                    
                    this.isDeletingWorldEntry = true;
                    
                    try {
                        const res = await axios.post('/api/world-info/delete-entry', {
                            world_name: worldName,
                            entry_uid: entryUid
                        });
                        
                        if (res.data.success) {
                            // Remove from memory
                            const worldIndex = this.worldInfos.findIndex(w => w.name === worldName);
                            if (worldIndex !== -1) {
                                delete this.worldInfos[worldIndex].entries[entryUid];
                            }
                            alert("World info entry deleted successfully!");
                        } else {
                            alert(`Error deleting entry: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error("Failed to delete world entry", e);
                        alert("Failed to delete world info entry. Is the backend running?");
                    } finally {
                        this.isDeletingWorldEntry = false;
                    }
                },

                async editWorldEntryAI(section) {
                    if (!this.editingWorldEntry || !this.editingWorldEntry.world_name) {
                        alert("Please select a world info entry first.");
                        return;
                    }
                    
                    this.isEditingWorldEntry = true;
                    
                    let contextText = "";
                    if (this.worldEditContextMode === 'manual') {
                        if (!this.worldEditContextText.trim()) {
                            alert("Please provide context for AI generation.");
                            this.isEditingWorldEntry = false;
                            return;
                        }
                        contextText = this.worldEditContextText;
                    } else {
                        // Use current chat context
                        if (this.messages.length === 0) {
                            alert("Start a conversation first to extract details.");
                            this.isEditingWorldEntry = false;
                            return;
                        }
                        // Use last 50 messages for context
                        contextText = this.messages.slice(-50).map(m => `${m.speaker || (m.role === 'user' ? 'User' : 'Narrator')}: ${m.content}`).join('\n');
                    }
                    
                    try {
                        const res = await axios.post('/api/world-info/edit-entry-ai', {
                            world_name: this.editingWorldEntry.world_name,
                            entry_uid: this.editingWorldEntry.entry_uid,
                            section: section,
                            tone: this.worldGen.tone || 'sfw',
                            context: contextText,
                            source_mode: this.worldEditContextMode
                        });
                        
                        if (res.data.success) {
                            // Update the entry content
                            this.editingWorldEntry.entry.content = res.data.text;
                            alert(`${section} content updated successfully!`);
                        } else {
                            alert(`Error updating ${section}: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error(`Failed to edit ${section}`, e);
                        alert(`Connection error updating ${section}. Is the backend running?`);
                    } finally {
                        this.isEditingWorldEntry = false;
                    }
                },

                scrollToBottom() {
                    setTimeout(() => {
                        const container = document.getElementById('chat-container');
                        if (container) container.scrollTop = container.scrollHeight;
                    }, 50);
                },

                // Forking functionality
                showForkDialog: false,
                forkBranchName: '',
                isForking: false,
                showBranchDialog: false,
                currentChatBranches: [],
                showRenameDialog: false,
                renameBranchName: '',
                isRenaming: false,
                currentChatName: '',

                async createForkFromMessage(msgId) {
                    if (this.isForking) return;
                    
                    this.isForking = true;
                    
                    try {
                        // Generate branch name from message content
                        const msg = this.messages.find(m => m.id === msgId);
                        let branchName = 'Fork';
                        if (msg && msg.content) {
                            const preview = msg.content.length > 30 ? msg.content.substring(0, 27) + '...' : msg.content;
                            const timestamp = new Date().toLocaleString();
                            branchName = `Fork from ${timestamp} - "${preview}"`;
                        }
                        
                        const res = await axios.post('/api/chats/fork', {
                            origin_chat_name: this.currentChatName || 'current',
                            fork_from_message_id: msgId,
                            branch_name: branchName
                        });
                        
                        if (res.data.success) {
                            alert(`Branch "${branchName}" created successfully!`);
                            // Load the new branch immediately
                            this.loadChat(res.data.name);
                        } else {
                            alert(`Failed to create branch: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error('Fork creation failed', e);
                        alert('Failed to create branch. Is the backend running?');
                    } finally {
                        this.isForking = false;
                    }
                },

                async openForkDialog(msgId) {
                    this.forkBranchName = '';
                    this.isForking = false;
                    this.showForkDialog = true;
                    this.forkMessageId = msgId;
                    
                    // Generate default branch name based on message content
                    const msg = this.messages.find(m => m.id === msgId);
                    if (msg && msg.content) {
                        const preview = msg.content.length > 30 ? msg.content.substring(0, 27) + '...' : msg.content;
                        const timestamp = new Date().toLocaleString();
                        this.forkBranchName = `Fork from ${timestamp} - "${preview}"`;
                    }
                },

                async createFork() {
                    if (!this.forkBranchName || this.isForking) return;
                    
                    this.isForking = true;
                    
                    try {
                        const res = await axios.post('/api/chats/fork', {
                            origin_chat_name: this.currentChatName || 'current',
                            fork_from_message_id: this.forkMessageId,
                            branch_name: this.forkBranchName
                        });
                        
                        if (res.data.success) {
                            alert(`Branch "${this.forkBranchName}" created successfully!`);
                            this.showForkDialog = false;
                            // Refresh chat list to show new branch
                            await this.fetchChats();
                            // Load the new branch
                            this.loadChat(res.data.name);
                        } else {
                            alert(`Failed to create branch: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error('Fork creation failed', e);
                        alert('Failed to create branch. Is the backend running?');
                    } finally {
                        this.isForking = false;
                    }
                },

                async showBranchDialog(chatName) {
                    this.currentChatName = chatName;
                    try {
                        const res = await axios.get(`/api/chats/${chatName}/branches`);
                        this.currentChatBranches = res.data || [];
                        this.showBranchDialog = true;
                    } catch (e) {
                        console.error('Failed to load branches', e);
                        alert('Failed to load branches.');
                    }
                },

                async renameBranchDialog(branch) {
                    this.renameBranchName = branch.branch_name || branch.name;
                    this.currentBranchToRename = branch;
                    this.showRenameDialog = true;
                },

                async renameBranch() {
                    if (!this.renameBranchName || this.isRenaming) return;
                    
                    this.isRenaming = true;
                    
                    try {
                        const res = await axios.put(`/api/chats/${this.currentBranchToRename.name}/rename-branch`, {
                            branch_name: this.renameBranchName
                        });
                        
                        if (res.data.success) {
                            alert('Branch renamed successfully!');
                            this.showRenameDialog = false;
                            // Refresh the branches list
                            await this.showBranchDialog(this.currentChatName);
                        } else {
                            alert(`Failed to rename branch: ${res.data.error}`);
                        }
                    } catch (e) {
                        console.error('Branch rename failed', e);
                        alert('Failed to rename branch.');
                    } finally {
                        this.isRenaming = false;
                    }
                },

                // Performance management
                performanceStatus: {
                    performance_mode_enabled: true,
                    status: { llm: 'idle', sd: 'idle', llm_queue_length: 0, sd_queue_length: 0 },
                    median_llm_time: null,
                    median_sd_time: null
                },
                performanceHints: [],
                
                // Service connection status
                serviceStatus: {
                    kobold: { status: 'disconnected', details: 'Not checked', latency_ms: 0 },
                    sd: { status: 'disconnected', details: 'Not checked', latency_ms: 0 }
                },
                isCheckingConnections: false,

                async togglePerformanceMode() {
                    try {
                        await axios.post('/api/performance/toggle', { enabled: this.settings.performance_mode_enabled });
                        await this.updatePerformanceStatus();
                    } catch (e) {
                        console.error('Failed to toggle performance mode', e);
                    }
                },

                async updatePerformanceStatus() {
                    try {
                        const res = await axios.get('/api/performance/status');
                        this.performanceStatus = res.data;
                    } catch (e) {
                        console.error('Failed to fetch performance status', e);
                    }
                },

                async dismissHint(hintId) {
                    try {
                        await axios.post('/api/performance/dismiss-hint', { hint_id: hintId });
                        this.performanceHints = this.performanceHints.filter(h => h.id !== hintId);
                    } catch (e) {
                        console.error('Failed to dismiss hint', e);
                    }
                },

                // Connection Management Functions
                async checkKoboldConnection() {
                    this.isCheckingConnections = true;
                    try {
                        const res = await axios.get('/api/health/kobold');
                        this.serviceStatus.kobold = res.data;
                    } catch (e) {
                        this.serviceStatus.kobold = {
                            status: 'disconnected',
                            details: 'Connection failed',
                            latency_ms: 0
                        };
                    } finally {
                        this.isCheckingConnections = false;
                    }
                },

                async checkSDConnection() {
                    this.isCheckingConnections = true;
                    try {
                        const res = await axios.get('/api/health/sd');
                        this.serviceStatus.sd = res.data;
                    } catch (e) {
                        this.serviceStatus.sd = {
                            status: 'disconnected',
                            details: 'Connection failed',
                            latency_ms: 0
                        };
                    } finally {
                        this.isCheckingConnections = false;
                    }
                },

                async checkAllServices() {
                    await Promise.all([
                        this.checkKoboldConnection(),
                        this.checkSDConnection()
                    ]);
                },

                async testConnection(service) {
                    if (service === 'kobold') {
                        await this.checkKoboldConnection();
                    } else if (service === 'sd') {
                        await this.checkSDConnection();
                    }
                },

                isServiceConnected(service) {
                    return this.serviceStatus[service]?.status === 'connected';
                },

                getServiceStatusText(service) {
                    const status = this.serviceStatus[service];
                    if (!status) return 'Unknown';
                    
                    switch (status.status) {
                        case 'connected':
                            return `Connected (${status.latency_ms}ms)`;
                        case 'disconnected':
                            return 'Disconnected';
                        case 'testing':
                            return 'Testing...';
                        default:
                            return status.details || 'Unknown';
                    }
                },

                getServiceStatusClass(service) {
                    const status = this.serviceStatus[service]?.status;
                    switch (status) {
                        case 'connected':
                            return 'bg-green-500/20 text-green-400 border-green-500/30';
                        case 'disconnected':
                            return 'bg-red-500/20 text-red-400 border-red-500/30';
                        case 'testing':
                            return 'bg-yellow-500/20 text-yellow-400 border-yellow-500/30';
                        default:
                            return 'bg-slate-500/20 text-slate-400 border-slate-500/30';
                    }
                },

                // Graceful feature degradation
                canGenerateText() {
                    return this.isServiceConnected('kobold');
                },

                canGenerateImages() {
                    return this.isServiceConnected('sd');
                },

                // Update API URLs and test connections
                async updateAPIURLs() {
                    // Update config URLs
                    CONFIG.kobold_url = this.config.kobold_url;
                    CONFIG.sd_url = this.config.sd_url;
                    
                    // Test connections with new URLs
                    await this.checkAllServices();
                },

                // World Info Cache Management
                cacheStats: { size: 0, max_size: 1000, usage_percent: 0 },
                cacheConfig: { max_size: 1000 },
                isFetchingCache: false,
                isClearingCache: false,
                isUpdatingCache: false,

                async fetchCacheStats() {
                    this.isFetchingCache = true;
                    try {
                        const res = await axios.get('/api/world-info/cache/stats');
                        if (res.data.success) {
                            this.cacheStats = res.data.stats;
                        }
                    } catch (e) {
                        console.error('Failed to fetch cache stats', e);
                        alert('Failed to fetch cache statistics. Is the backend running?');
                    } finally {
                        this.isFetchingCache = false;
                    }
                },

                async clearCache() {
                    if (!confirm('Clear the world info cache? This will remove all cached entries and may slow down world info processing temporarily.')) {
                        return;
                    }
                    
                    this.isClearingCache = true;
                    try {
                        const res = await axios.post('/api/world-info/cache/clear');
                        if (res.data.success) {
                            alert('World info cache cleared successfully!');
                            // Refresh stats after clearing
                            await this.fetchCacheStats();
                        } else {
                            alert('Failed to clear cache: ' + res.data.error);
                        }
                    } catch (e) {
                        console.error('Failed to clear cache', e);
                        alert('Failed to clear cache. Is the backend running?');
                    } finally {
                        this.isClearingCache = false;
                    }
                },

                async updateCacheConfig() {
                    if (!this.cacheConfig.max_size || this.cacheConfig.max_size < 0) {
                        alert('Please enter a valid cache size (0 for unlimited, or a positive number)');
                        return;
                    }
                    
                    this.isUpdatingCache = true;
                    try {
                        const res = await axios.post('/api/world-info/cache/configure', {
                            max_size: this.cacheConfig.max_size
                        });
                        
                        if (res.data.success) {
                            alert(`Cache size limit updated to ${res.data.max_size} entries`);
                            // Refresh stats after updating
                            await this.fetchCacheStats();
                        } else {
                            alert('Failed to update cache config: ' + res.data.error);
                        }
                    } catch (e) {
                        console.error('Failed to update cache config', e);
                        alert('Failed to update cache configuration. Is the backend running?');
                    } finally {
                        this.isUpdatingCache = false;
                    }
                },

                // Helper functions for branch display
                isBranch(chatName) {
                    // Check if this chat is a branch by looking for metadata
                    return chatName.includes('_fork_');
                },

                getDisplayName(chatName) {
                    // Try to get the display name from metadata if available
                    return chatName;
                },

                getBranchOrigin(chatName) {
                    // Extract origin chat name from fork filename
                    const match = chatName.match(/^(.+)_fork_\d+$/);
                    return match ? match[1] : 'Unknown';
                },

                formatTime(timestamp) {
                    if (!timestamp) return 'Unknown time';
                    const date = new Date(timestamp * 1000);
                    return date.toLocaleString();
                },

                async copyImageSettings(imageUrl) {
                    try {
                        // Extract filename from URL like "/images/sd_123456789.png"
                        const filename = imageUrl.split('/').pop();

                        // Fetch image metadata from backend
                        const res = await axios.get(`/api/image-metadata/${filename}`);

                        if (res.data.success && res.data.metadata) {
                            const metadata = res.data.metadata;

                            // Update the SD parameters with the retrieved settings
                            this.sdParams.prompt = metadata.prompt;
                            this.sdParams.negative_prompt = metadata.negative_prompt;
                            this.sdParams.steps = metadata.steps;
                            this.sdParams.cfg_scale = metadata.cfg_scale;
                            this.sdParams.width = metadata.width;
                            this.sdParams.height = metadata.height;
                            this.sdParams.sampler_name = metadata.sampler_name;
                            this.sdParams.scheduler = metadata.scheduler;

                            // Show the image generator panel
                            this.showImagePanel = true;

                            // Scroll to the image generator panel
                            setTimeout(() => {
                                const container = document.getElementById('chat-container');
                                if (container) container.scrollTop = container.scrollHeight;
                            }, 100);

                            alert('Image settings copied to the generator panel!');
                        } else {
                            alert('No metadata found for this image. It may have been generated before metadata tracking was implemented.');
                        }
                    } catch (e) {
                        console.error('Failed to copy image settings:', e);
                        alert('Failed to copy image settings. The image may not have metadata stored.');
                    }
                },

                // Inpaint Functions
                openInpaintDialog(message, index) {
                    this.inpaintImageUrl = message.image;
                    this.inpaintMessageIndex = index;
                    this.inpaintPrompt = '';
                    this.brushHistory = [];
                    this.showInpaintDialog = true;
                    
                    // Setup keyboard listener for Ctrl+Z
                    document.addEventListener('keydown', this.handleInpaintKeyboard);
                },

                closeInpaintDialog() {
                    this.showInpaintDialog = false;
                    this.inpaintImageUrl = '';
                    this.inpaintPrompt = '';
                    this.inpaintMessageIndex = null;
                    this.brushHistory = [];
                    
                    // Remove keyboard listener
                    document.removeEventListener('keydown', this.handleInpaintKeyboard);
                },

                handleInpaintKeyboard(e) {
                    // Ctrl+Z for undo
                    if (e.ctrlKey && e.key === 'z') {
                        e.preventDefault();
                        this.undoBrushStroke();
                    }
                },

                initializeInpaintCanvas() {
                    const img = document.getElementById('inpaint-image');
                    const canvas = document.getElementById('inpaint-canvas');
                    
                    if (!img || !canvas) return;
                    
                    // Set canvas to match image dimensions exactly
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;
                    canvas.style.width = img.width + 'px';
                    canvas.style.height = img.height + 'px';
                    
                    // Initialize contexts
                    this.overlayCtx = canvas.getContext('2d');
                    
                    // Create offscreen mask canvas
                    this.maskCanvas = document.createElement('canvas');
                    this.maskCanvas.width = img.naturalWidth;
                    this.maskCanvas.height = img.naturalHeight;
                    this.maskCtx = this.maskCanvas.getContext('2d');
                    
                    // Clear any previous drawings
                    this.clearMask();
                },

                startDrawing(e) {
                    this.isDrawing = true;
                    this.draw(e);
                },

                draw(e) {
                    if (!this.isDrawing) return;
                    
                    const canvas = document.getElementById('inpaint-canvas');
                    const rect = canvas.getBoundingClientRect();
                    
                    // Calculate position relative to canvas, accounting for scaling
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;
                    
                    // Draw on mask canvas (white on black)
                    this.maskCtx.fillStyle = 'white';
                    this.maskCtx.beginPath();
                    this.maskCtx.arc(x, y, this.brushSize / 2, 0, Math.PI * 2);
                    this.maskCtx.fill();
                    
                    // Draw visual overlay (semi-transparent red at 30% opacity)
                    this.overlayCtx.fillStyle = 'rgba(255, 100, 100, 0.3)';
                    this.overlayCtx.beginPath();
                    this.overlayCtx.arc(x, y, this.brushSize / 2, 0, Math.PI * 2);
                    this.overlayCtx.fill();
                },

                stopDrawing() {
                    if (this.isDrawing) {
                        // Save current state to history for undo
                        const imageData = this.maskCtx.getImageData(0, 0, this.maskCanvas.width, this.maskCanvas.height);
                        this.brushHistory.push(imageData);
                        this.isDrawing = false;
                    }
                },

                undoBrushStroke() {
                    if (this.brushHistory.length === 0) return;
                    
                    // Remove last stroke from history
                    this.brushHistory.pop();
                    
                    // Restore to previous state (or clear if no history)
                    if (this.brushHistory.length > 0) {
                        const previousState = this.brushHistory[this.brushHistory.length - 1];
                        this.maskCtx.putImageData(previousState, 0, 0);
                    } else {
                        // Clear mask completely
                        this.maskCtx.fillStyle = 'black';
                        this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
                    }
                    
                    // Redraw overlay to match
                    this.redrawOverlay();
                },

                redrawOverlay() {
                    // Clear overlay
                    this.overlayCtx.clearRect(0, 0, this.overlayCtx.canvas.width, this.overlayCtx.canvas.height);
                    
                    // Redraw from mask canvas
                    const imageData = this.maskCtx.getImageData(0, 0, this.maskCanvas.width, this.maskCanvas.height);
                    const data = imageData.data;
                    
                    this.overlayCtx.fillStyle = 'rgba(255, 100, 100, 0.3)';
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i] > 128) { // If pixel is white-ish in mask
                            const pixelIndex = i / 4;
                            const x = pixelIndex % this.maskCanvas.width;
                            const y = Math.floor(pixelIndex / this.maskCanvas.width);
                            this.overlayCtx.fillRect(x, y, 1, 1);
                        }
                    }
                },

                clearMask() {
                    if (!this.maskCtx || !this.overlayCtx) return;
                    
                    // Clear mask canvas (black background)
                    this.maskCtx.fillStyle = 'black';
                    this.maskCtx.fillRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);
                    
                    // Clear overlay canvas
                    this.overlayCtx.clearRect(0, 0, this.overlayCtx.canvas.width, this.overlayCtx.canvas.height);
                    
                    // Clear history
                    this.brushHistory = [];
                },

                async generateInpaintPreview() {
                    if (!this.inpaintPrompt.trim()) {
                        alert('Please enter an inpaint prompt.');
                        return;
                    }
                    
                    this.isInpainting = true;
                    
                    try {
                        // Get original image as base64
                        const img = document.getElementById('inpaint-image');
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = img.naturalWidth;
                        tempCanvas.height = img.naturalHeight;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(img, 0, 0);
                        const imageBase64 = tempCanvas.toDataURL('image/png').split(',')[1];
                        
                        // Get mask as base64
                        const maskBase64 = this.maskCanvas.toDataURL('image/png').split(',')[1];
                        
                        // Send to backend
                        const res = await axios.post('/api/inpaint', {
                            image: imageBase64,
                            mask: maskBase64,
                            prompt: this.inpaintPrompt,
                            width: img.naturalWidth,
                            height: img.naturalHeight,
                            denoising_strength: this.inpaintDenoisingStrength
                        });
                        
                        if (res.data.url) {
                            // Store the preview (not yet committed to chat)
                            this.inpaintPreviewUrl = res.data.url;
                            this.isPreviewMode = true;
                            
                            // Backup original image URL if not already backed up
                            if (!this.originalImageBackup) {
                                this.originalImageBackup = this.inpaintImageUrl;
                            }
                        } else {
                            alert('Inpainting failed: ' + (res.data.error || 'Unknown error'));
                        }
                    } catch (e) {
                        console.error('Inpaint failed:', e);
                        alert('Inpainting failed. Is the SD backend running?');
                    } finally {
                        this.isInpainting = false;
                    }
                },

                acceptInpaint() {
                    if (!this.inpaintPreviewUrl) return;
                    
                    // Commit the preview to the actual message
                    this.messages[this.inpaintMessageIndex].image = this.inpaintPreviewUrl;
                    
                    // Close the dialog
                    this.closeInpaintDialog();
                    
                    alert('Inpaint accepted and published to chat!');
                },

                discardInpaint() {
                    // Clear the preview and return to editing mode
                    this.inpaintPreviewUrl = null;
                    this.isPreviewMode = false;
                    
                    // Optionally clear the mask too for a fresh start
                    this.clearMask();
                },

                closeInpaintDialog() {
                    this.showInpaintDialog = false;
                    this.inpaintImageUrl = '';
                    this.inpaintPrompt = '';
                    this.inpaintMessageIndex = null;
                    this.brushHistory = [];
                    this.inpaintPreviewUrl = null;
                    this.isPreviewMode = false;
                    this.originalImageBackup = null;
                    
                    // Remove keyboard listener
                    document.removeEventListener('keydown', this.handleInpaintKeyboard);
                }
            }
        }
    </script>
</body>
</html>
